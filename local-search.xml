<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hexo-blog/2024/12/10/hello-world/"/>
    <url>/hexo-blog/2024/12/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>再读《匆匆》</title>
    <link href="/hexo-blog/2024/12/10/%E5%86%8D%E8%AF%BB%E3%80%8A%E5%8C%86%E5%8C%86%E3%80%8B/"/>
    <url>/hexo-blog/2024/12/10/%E5%86%8D%E8%AF%BB%E3%80%8A%E5%8C%86%E5%8C%86%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="再读《匆匆》"><a href="#再读《匆匆》" class="headerlink" title="再读《匆匆》"></a>再读《匆匆》</h1><blockquote><p>“燕子去了，有再来的时候；杨柳枯了，有再青的时候；挑花谢了，有再开的时候。但是聪明的你告诉我，我们的日子为什么一去不复返呢？”</p></blockquote><p>今天偶然读到这句诗，内心涌起阵阵感慨。是的，聪明的你能告诉我，为什么我们的时光一去不复返呢？这句话至今依然萦绕在我的脑海中，尤其是回想起小学时光，已不觉间过去了整整11年。那时，我并不理解这句话的深意，只觉得课文内容枯燥难背，甚至有些同学因背错几句话或不通顺的词语，常常被班主任批评，手心也常遭戒尺惩罚，红肿的手心只能甩动吹风来缓解痛感。虽然老师偶尔也会惩罚我，但次数不多。一方面是因为当时我的成绩尚可，当时我和堂哥在同班学习，像许多父母一样，他们总喜欢将我和他作比较。尽管我并不热衷学习，总是趁着课间去操场玩耍，在田野间奔跑，而我的堂哥则总是专注于学习，每次成绩比我好，父母总是会拿我和他比较。那时的我好胜心强烈，心里总想着，下次我要比他考得更好，争取获得更多的零花钱。于是，在这不断的较量中，我的成绩逐渐进步，虽然从未进入过前三名，但总是能保持在前五、六名之间。</p><p>另外，戒尺的故事也颇具趣味。它是由我父亲亲手制作的。那时，家里同我的二叔一起经营着一个小型沙发作坊，木材资源充足。每年开学时，班主任都会委托我父亲制作一根戒尺，而父亲总是欣然应允，还常对我说：“好学生都是被打出来的。”制作戒尺并不复杂，选用经过切割的木材，利用切割机去除多余部分，最后通过木工刨光滑。每次将戒尺送到老师手中时，她都会赞扬父亲的手艺，感激他精心制作的戒尺，因为其他老师使用的戒尺不过是随便从枯木上折来的一根树枝罢了。</p><p>写到这里，回忆如泉水般汹涌而来，仿佛一切都发生在昨日，往事历历在目，每一个片段依然刻骨铭心。</p><p>虽然我被打的次数很少，但总还是有的。班主任陪伴我们六年，她是一位非常严格的老师，每当同学犯错时，她总喜欢在全班面前当场批评，甚至一节语文课就常常变成了班会课。对于我们这些旁观者来说，倒是无比轻松，毕竟少了一节那时让人觉得冗长的语文课。而那些被批评的同学只能低下头，默默等待下课铃的响起。每当听到老师批评别人时，我总会心生些许畏惧。但是若看到朋友犯错被迫罚上“思想教育课”，我总会在桌前低头忍不住偷笑。有一次实在憋不住，笑出了声，结果也被老师叫上讲台罚站。站在台上，看着台下的同学们，我虽然忍住了笑声，却依然难掩脸上的笑意。老师见我罚站没有效果，便命令我伸出手，戒尺狠狠地打在我的手心，直到我忍不住流下眼泪才停手。对于其他的惩罚，戒尺的效果无疑是显著的，但在这件事上，我始终屡教不改，直到毕业。回头想，那时的老师也不过二十几岁，虽然年轻，却充满了对我们的期望与希望。她延续这上一代父辈的教育理念，对我们这些从学前班就跟着她的孩子们寄托了巨大的期望，盼望着我们能成才，正如她常说的“望子成龙，望女成凤”。在她严格的教育下，我们的成长与进步离不开她的辛勤付出。临近毕业时，老师常常与我们谈心，告诉我们这些年是我们最美好的时光，是最宝贵的童年回忆。那时的我们显然无法理解，总觉得这些话如同空洞的鸡汤。对于当时的我来说，唯一渴望的是过上不需要考试、不用写作业的生活，觉得那才是最自由的生活。如今回过头来看，曾经的自己真是幼稚天真。那时，时间仿佛过得很慢，每一节课似乎都拖得很长，下课铃声迟迟不响，短短的放学回家路也能被我们走出十万八千里。而随着年岁的增长，我对时间的感知也发生了变化，日子仿佛被谁按下了快进键，岁月变得飞快，一切都匆匆而过。</p><blockquote><p>在逃去如飞的日子里，在千门万户的世界里的我能做些什么呢？只有徘徊罢了，只有匆匆罢了；在八千多日的匆匆里，除徘徊外，又剩些什么呢？过去的日子如轻烟，被微风吹散了，如薄雾，被初阳蒸融了；我留着些什么痕迹呢？我何曾留着像游丝样的痕迹呢？我赤裸裸来到这世界，转眼间也将赤裸裸的回去罢？但不能平的，为什么偏要白白走这一遭啊？</p></blockquote><p>正如《匆匆》中所写，过去的时光如烟消云散，未曾留下任何痕迹。过去的几年尤为如此，唯一的变化是年龄的增长与父母的渐渐老去。曾经我以为自己在学习上拥有少许天赋，然而这几年的经历，在学习上屡屡失利，几次重大考试的失利让我意识到，也逐渐认识到自己给自己披上的耀眼外衣是时候脱下来了。尽管如此，我依然心存不甘，难以坦然面对平凡的自己。这几年，我也变得沉默寡言，究竟是身体原因让言语受限，还是经历太多让人变得沉默寡言，恐怕两者皆有。</p><p>总之人生总有那么一个时刻，或由一件小事，亦或者是一件物品回忆起过往的种种。今天由《匆匆》忆匆匆，只觉匆匆。抛下伤感情绪，明天又是新开始！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 树和二叉树</title>
    <link href="/hexo-blog/2024/11/10/4.%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/hexo-blog/2024/11/10/4.%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">·<br></code></pre></td></tr></table></figure><h3 id="树的存储结构（树的表示）"><a href="#树的存储结构（树的表示）" class="headerlink" title="树的存储结构（树的表示）"></a>树的存储结构（树的表示）</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentalTree</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> data;   <span class="hljs-comment">//节点数据</span><br>        <span class="hljs-type">int</span> parent; <span class="hljs-comment">//父节点的索引</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data, <span class="hljs-type">int</span> parent)</span> &#123;<br>            <span class="hljs-built_in">this</span>.data = data;<br>            <span class="hljs-built_in">this</span>.parent = parent;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode[] nodes;   <span class="hljs-comment">//保存树的节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;   <span class="hljs-comment">//树的大小</span><br><br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParentalTree</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSzie)</span> &#123;<br>        nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>[maxSzie];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//添加节点,parentIndex 是父节点的索引</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data, <span class="hljs-type">int</span> parent)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size &gt;= nodes.length)   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Tree is full&quot;</span>);<br>        nodes[size] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(data, parent);<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">//获取某个节点的父节点索引</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getParentIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= nodes.length) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;索引超出范围&quot;</span>);<br>        <span class="hljs-keyword">return</span> nodes[index].parent;<br>    &#125;<br><br>    <span class="hljs-comment">//获取蘑菇节点的数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNodeData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;索引超出范围&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nodes[index].data;<br>    &#125;<br><br>    <span class="hljs-comment">//获取根节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRootIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nodes[i].parent == -<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Tree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 创建一个最多10个节点的树</span><br>        tree.addNode(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// 添加根节点，数据为1</span><br>        tree.addNode(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 添加节点1，父节点是根节点</span><br>        tree.addNode(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 添加节点2，父节点是根节点</span><br>        tree.addNode(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 添加节点3，父节点是节点1</span><br><br>        tree.printTree(); <span class="hljs-comment">// 打印树的结构</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">childrenTree</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;    <span class="hljs-comment">//孩子表示法</span><br>        String data;    <span class="hljs-comment">//节点数据</span><br>        LinkedList&lt;TreeNode&gt; children;  <span class="hljs-comment">//孩子节点的链表</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(String data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.data = data;<br>            children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-comment">//添加子节点</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addChild</span><span class="hljs-params">(TreeNode child)</span> &#123;<br>            children.add(child);<br>        &#125;<br><br>        <span class="hljs-comment">//删除子节点</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeChild</span><span class="hljs-params">(TreeNode child)</span> &#123;<br>            children.remove(child);<br>        &#125;<br><br>        <span class="hljs-comment">//获取子节点列表</span><br>        <span class="hljs-keyword">public</span> LinkedList&lt;TreeNode&gt; <span class="hljs-title function_">getChildren</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> children;<br>        &#125;<br><br>        <span class="hljs-comment">//获取节点数据</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取树的深度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDepth</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点算作一层</span><br>            <span class="hljs-keyword">for</span> (TreeNode child : children) &#123;<br>                depth = Math.max(depth, <span class="hljs-number">1</span> + child.getDepth()); <span class="hljs-comment">// 递归计算深度</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> depth;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="孩子兄弟表示法（二叉树表示法）"><a href="#孩子兄弟表示法（二叉树表示法）" class="headerlink" title="孩子兄弟表示法（二叉树表示法）"></a>孩子兄弟表示法（二叉树表示法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">binaryTree</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        String data;    <span class="hljs-comment">//节点数据</span><br>        TreeNode firstChild;   <span class="hljs-comment">//指向第一个子节点</span><br>        TreeNode nextSibling;   <span class="hljs-comment">//指向下一个兄弟节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(String data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.data = data;<br>            <span class="hljs-built_in">this</span>.firstChild = <span class="hljs-literal">null</span>;<br>            <span class="hljs-built_in">this</span>.nextSibling = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">binaryTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-string">&quot;root&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//添加子节点，如果父节点没有子节点，则直接添加；否则，添加为最后一个兄弟节点。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addChild</span><span class="hljs-params">(TreeNode parent, String childData)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(childData);<br>        <span class="hljs-keyword">if</span> (parent.firstChild == <span class="hljs-literal">null</span>) &#123;<br>            parent.firstChild = child; <span class="hljs-comment">//如果没有子节点，直接添加</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">sibling</span> <span class="hljs-operator">=</span> parent.firstChild;<br>            <span class="hljs-keyword">while</span> (sibling.nextSibling != <span class="hljs-literal">null</span>) &#123;<br>                sibling = sibling.nextSibling;  <span class="hljs-comment">//找到最后一个兄弟节点</span><br>            &#125;<br>            sibling.nextSibling = child;    <span class="hljs-comment">//添加为最后一个兄弟节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除节点，该方法接受一个父节点和要删除的目标数据。</span><br>    <span class="hljs-comment">//首先检查当前父节点的第一个子节点。如果找到目标节点，调整指针以跳过该节点，从而实现删除。</span><br>    <span class="hljs-comment">//如果目标节点不是直接子节点，则递归地对所有子节点调用 deleteNode 方法。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode parent, String targetData)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> parent.firstChild;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">previous</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current.data.equals(targetData)) &#123;<br>                <span class="hljs-comment">// 找到目标节点</span><br>                <span class="hljs-keyword">if</span> (previous == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果是第一个子节点</span><br>                    parent.firstChild = current.nextSibling; <span class="hljs-comment">// 直接跳过当前节点</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    previous.nextSibling = current.nextSibling; <span class="hljs-comment">// 跳过当前节点</span><br>                &#125;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 删除后退出</span><br>            &#125;<br>            previous = current;<br>            current = current.nextSibling; <span class="hljs-comment">// 继续查找</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果目标节点是子节点的子节点，递归删除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">TreeNode</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> parent.firstChild; child != <span class="hljs-literal">null</span>; child = child.nextSibling) &#123;<br>            deleteNode(child, targetData);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 获取树的深度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDepth</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点算作一层</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">TreeNode</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> node.firstChild; child != <span class="hljs-literal">null</span>; child = child.nextSibling) &#123;<br>            depth = Math.max(depth, <span class="hljs-number">1</span> + getDepth(child)); <span class="hljs-comment">// 递归计算深度</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBinaryTree</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] tree; <span class="hljs-comment">// 存储二叉树的数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// 当前节点数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[capacity]; <span class="hljs-comment">// 初始化数组</span><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (size &lt; tree.length) &#123;<br>            tree[size++] = value; <span class="hljs-comment">// 在数组末尾插入</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;树已满，无法插入新节点！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>     <span class="hljs-comment">// 删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> findIndex(value);<br>        <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;未找到要删除的节点：&quot;</span> + value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 节点不存在</span><br>        &#125;<br><br>        <span class="hljs-comment">// 将最后一个节点的值替换到删除的位置</span><br>        tree[index] = tree[size - <span class="hljs-number">1</span>];<br>        tree[size - <span class="hljs-number">1</span>] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除最后一个位置的值</span><br>        size--; <span class="hljs-comment">// 减少节点数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找节点的索引</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span> (tree[i].equals(value)) &#123;<br>                <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 返回找到的索引</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到</span><br>    &#125;<br><br>  <br>    <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderTraversal</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; size) &#123;<br>            System.out.print(tree[index] + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 访问当前节点</span><br>            preOrderTraversal(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 访问左子树</span><br>            preOrderTraversal(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>); <span class="hljs-comment">// 访问右子树</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderTraversal</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; size) &#123;<br>            inOrderTraversal(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 访问左子树</span><br>            System.out.print(tree[index] + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 访问当前节点</span><br>            inOrderTraversal(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>); <span class="hljs-comment">// 访问右子树</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrderTraversal</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; size) &#123;<br>            postOrderTraversal(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 访问左子树</span><br>            postOrderTraversal(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>); <span class="hljs-comment">// 访问右子树</span><br>            System.out.print(tree[index] + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 访问当前节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印树的结构（层次遍历）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            System.out.print(tree[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取树的节点数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">binaryLinkTree</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        String data; <span class="hljs-comment">// 节点数据（可以是任意类型）</span><br>        TreeNode left; <span class="hljs-comment">// 左子节点</span><br>        TreeNode right; <span class="hljs-comment">// 右子节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(String data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.data = data;<br>            <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;<br>            <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">binaryLinkTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入节点（简单的方式，按层次插入）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(data);<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            root = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 使用队列进行层次遍历</span><br>        java.util.Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.LinkedList&lt;&gt;();<br>        queue.add(root);<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> queue.poll();<br><br>            <span class="hljs-keyword">if</span> (current.left == <span class="hljs-literal">null</span>) &#123;<br>                current.left = newNode; <span class="hljs-comment">// 插入左子节点</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.add(current.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (current.right == <span class="hljs-literal">null</span>) &#123;<br>                current.right = newNode; <span class="hljs-comment">// 插入右子节点</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.add(current.right);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderTraversal</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 访问当前节点</span><br>            preOrderTraversal(node.left); <span class="hljs-comment">// 访问左子树</span><br>            preOrderTraversal(node.right); <span class="hljs-comment">// 访问右子树</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderTraversal</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            inOrderTraversal(node.left); <span class="hljs-comment">// 访问左子树</span><br>            System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 访问当前节点</span><br>            inOrderTraversal(node.right); <span class="hljs-comment">// 访问右子树</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrderTraversal</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            postOrderTraversal(node.left); <span class="hljs-comment">// 访问左子树</span><br>            postOrderTraversal(node.right); <span class="hljs-comment">// 访问右子树</span><br>            System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 访问当前节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> (root.data.equals(value)) &#123;<br>            root = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 删除根节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> deleteNode(root, value);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode parent, String value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 查找要删除的节点</span><br>        <span class="hljs-keyword">if</span> (parent.left != <span class="hljs-literal">null</span> &amp;&amp; parent.left.data.equals(value)) &#123;<br>            parent.left = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 删除左子节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (parent.right != <span class="hljs-literal">null</span> &amp;&amp; parent.right.data.equals(value)) &#123;<br>            parent.right = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 删除右子节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 递归查找</span><br>        <span class="hljs-keyword">return</span> deleteNode(parent.left, value) || deleteNode(parent.right, value);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取根节点</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">getRoot</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> &#123;<br><br>    TreeNode root;<br><br>    <span class="hljs-comment">// 删除节点</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到要删除的节点</span><br>        <span class="hljs-keyword">if</span> (key &lt; root.val) &#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root.val) &#123;<br>            root.right = deleteNode(root.right, key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 找到节点，处理三种情况</span><br><br>            <span class="hljs-comment">// 情况 1: 当前节点没有子节点</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 情况 2: 当前节点只有一个子节点</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br><br>            <span class="hljs-comment">// 情况 3: 当前节点有两个子节点</span><br>            <span class="hljs-comment">// 找到右子树的最小节点（即后继）</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> findMin(root.right);<br>            root.val = minNode.val; <span class="hljs-comment">// 用后继节点的值替代当前节点</span><br>            root.right = deleteNode(root.right, minNode.val); <span class="hljs-comment">// 删除后继节点</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助函数：找到最小节点</span><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">findMin</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他辅助函数（如插入、遍历等）可以在此实现</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Traversal</span> &#123;<br><br>    <span class="hljs-comment">//二叉树节点类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        String data;<br>        TreeNode left;<br>        TreeNode right;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(String data)</span> &#123;<br>            <span class="hljs-built_in">this</span>.data = data;<br>            left = <span class="hljs-literal">null</span>;<br>            right = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    TreeNode root;  <span class="hljs-comment">//根节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Traversal</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//插入节点（层次插入）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(data);<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            root = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">//创建队列，用于存储二叉树节点</span><br>        queue.add(root);    <span class="hljs-comment">//加入根，开始遍历树</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();   <span class="hljs-comment">//出队，检查左右节点是否为空，空则插入，非空则将其入队继续遍历</span><br><br>            <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<br>                node.left = newNode;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> queue.add(node.left);<br>            <span class="hljs-keyword">if</span> (node.right == <span class="hljs-literal">null</span>) &#123;<br>                node.right = newNode;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> queue.add(node.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//前序遍历，递归</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>);<br>            preOrder(node.left);<br>            preOrder(node.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//前序遍历，非递归 (通过栈来实现)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderIterative</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)   <span class="hljs-keyword">return</span>;<br><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(node);<br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> stack.pop();<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br><br>            <span class="hljs-comment">// 先右后左入栈，确保左子树先被访问</span><br>            <span class="hljs-keyword">if</span> (current.right != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(current.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current.left != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(current.left);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//中序遍历，递归</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            inOrder(node.left);<br>            System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>);<br>            inOrder(node.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//中序遍历，非递归</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderIterative</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> node;<br><br>        <span class="hljs-keyword">while</span> (current !=<span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(current);    <span class="hljs-comment">//左子节点入栈(一直向左入栈，直到为空表示无左孩子，此时可以访问节点（中序）)</span><br>                current = current.left;<br>            &#125;<br>            current = stack.pop();<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            current = current.right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//后续遍历，递归</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            postOrder(node.left);<br>            postOrder(node.right);<br>            System.out.print(node.data + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//后续遍历，非递归（两个栈的方式）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrderIterative</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)   <span class="hljs-keyword">return</span>;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(node);<br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> stack.pop();<br>            output.push(current);   <span class="hljs-comment">//先将当前节点压入输出栈</span><br><br>            <span class="hljs-comment">//先左后右入栈，确保右子树后被访问</span><br>            <span class="hljs-keyword">if</span> (current.left != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(current.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current.right != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(current.right);<br>            &#125;<br><br>            <span class="hljs-comment">//输出结果</span><br>            <span class="hljs-keyword">while</span> (!output.isEmpty()) &#123;<br>                System.out.print(output.pop().data + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>     <span class="hljs-comment">// 后序遍历，非递归（一个栈 + 一个指针实现）</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">lastVisited</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 记录上一个访问的节点</span><br>        stack.push(root);<br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> stack.peek();<br><br>            <span class="hljs-comment">// 如果当前节点没有子节点或子节点已经被访问过</span><br>            <span class="hljs-keyword">if</span> (current.left == <span class="hljs-literal">null</span> &amp;&amp; current.right == <span class="hljs-literal">null</span> || <br>                (lastVisited != <span class="hljs-literal">null</span> &amp;&amp; (lastVisited == current.left || lastVisited == current.right))) &#123;<br>                result.add(current.val); <span class="hljs-comment">// 访问当前节点</span><br>                lastVisited = stack.pop(); <span class="hljs-comment">// 更新上一个访问的节点</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 先压右子树，再压左子树，确保左子树先被处理</span><br>                <span class="hljs-keyword">if</span> (current.right != <span class="hljs-literal">null</span>) &#123;<br>                    stack.push(current.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (current.left != <span class="hljs-literal">null</span>) &#123;<br>                    stack.push(current.left);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他辅助方法可以在此实现</span><br>&#125;<br>  <br>  <br>    <span class="hljs-comment">//层序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)   <span class="hljs-keyword">return</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(node);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> queue.poll();<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">if</span> (current.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(current.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(current.right);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="通过序列确定唯一二叉树"><a href="#通过序列确定唯一二叉树" class="headerlink" title="通过序列确定唯一二叉树"></a>通过序列确定唯一二叉树</h3><h4 id="1-中序和先序构建"><a href="#1-中序和先序构建" class="headerlink" title="1.中序和先序构建"></a>1.中序和先序构建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br><br>    TreeNode(<span class="hljs-type">int</span> x) &#123;<br>        val = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTreeFromPreIn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> buildTree(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//边界确定</span><br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preStart]);<span class="hljs-comment">//通过先序确定根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inRootIndex</span> <span class="hljs-operator">=</span> findIndex(inorder, inStart, inEnd, root.val);<span class="hljs-comment">//找根节点在中序的索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> inRootIndex - inStart;<span class="hljs-comment">//在中序中，分割左右子树</span><br><br>        root.left = buildTree(preorder, preStart + <span class="hljs-number">1</span>, preStart + leftSize, inorder, inStart, inRootIndex - <span class="hljs-number">1</span>);<br>        root.right = buildTree(preorder, preStart + leftSize + <span class="hljs-number">1</span>, preEnd, inorder, inRootIndex + <span class="hljs-number">1</span>, inEnd);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] == value) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-中序和后序构建"><a href="#2-中序和后序构建" class="headerlink" title="2. 中序和后序构建"></a>2. 中序和后序构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTreeFromPostIn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>    <span class="hljs-keyword">return</span> buildTreeFromPostIn(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">buildTreeFromPostIn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (postStart &gt; postEnd || inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//边界判断</span><br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(postorder[postEnd]);<span class="hljs-comment">//通过后序找根节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">inRootIndex</span> <span class="hljs-operator">=</span> findIndex(inorder, inStart, inEnd, root.val);<span class="hljs-comment">//在中序中找根节点的索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> inRootIndex - inStart;<span class="hljs-comment">//分割左右子树</span><br><br>    root.left = buildTreeFromPostIn(postorder, postStart, postStart + leftSize - <span class="hljs-number">1</span>, inorder, inStart, inRootIndex - <span class="hljs-number">1</span>);<br>    root.right = buildTreeFromPostIn(postorder, postStart + leftSize, postEnd - <span class="hljs-number">1</span>, inorder, inRootIndex + <span class="hljs-number">1</span>, inEnd);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-中序和层序构建"><a href="#3-中序和层序构建" class="headerlink" title="3. 中序和层序构建"></a>3. 中序和层序构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTreeFromLevelIn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] levelorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>    <span class="hljs-keyword">return</span> buildTreeFromLevelIn(levelorder, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">buildTreeFromLevelIn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] levelorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(levelorder[<span class="hljs-number">0</span>]);<span class="hljs-comment">//通过层序找根</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">inRootIndex</span> <span class="hljs-operator">=</span> findIndex(inorder, inStart, inEnd, root.val);<span class="hljs-comment">//中序找根的索引</span><br>  <br>    <span class="hljs-comment">//从层序遍历中提取出左子树和右子树的节点</span><br>    <span class="hljs-type">int</span>[] leftLevel = Arrays.stream(levelorder).filter(x -&gt; findIndex(inorder, inStart, inEnd, x) &lt; inRootIndex).toArray();<br>    <span class="hljs-type">int</span>[] rightLevel = Arrays.stream(levelorder).filter(x -&gt; findIndex(inorder, inStart, inEnd, x) &gt; inRootIndex).toArray();<br><br>    root.left = buildTreeFromLevelIn(leftLevel, inorder, inStart, inRootIndex - <span class="hljs-number">1</span>);<br>    root.right = buildTreeFromLevelIn(rightLevel, inorder, inRootIndex + <span class="hljs-number">1</span>, inEnd);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\85366\AppData\Roaming\Typora\typora-user-images\image-20241021204826491.png" alt="image-20241021204826491"></p><h3 id="4-前序和层序构建"><a href="#4-前序和层序构建" class="headerlink" title="4. 前序和层序构建"></a>4. 前序和层序构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTreeFromPreLevel</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] levelorder)</span> &#123;<br>    <span class="hljs-keyword">return</span> buildTreeFromPreLevel(preorder, levelorder, <span class="hljs-number">0</span>, levelorder.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">buildTreeFromPreLevel</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] levelorder, <span class="hljs-type">int</span> levelStart, <span class="hljs-type">int</span> levelEnd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (levelStart &gt; levelEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (levelStart == levelEnd) <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftSubtreeRootValue</span> <span class="hljs-operator">=</span> preorder[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftSubtreeSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> levelStart; i &lt;= levelEnd; i++) &#123;<br>        <span class="hljs-keyword">if</span> (levelorder[i] == leftSubtreeRootValue) <span class="hljs-keyword">break</span>;<br>        leftSubtreeSize++;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] leftLevel = Arrays.copyOfRange(levelorder, levelStart, levelStart + leftSubtreeSize);<br>    <span class="hljs-type">int</span>[] rightLevel = Arrays.copyOfRange(levelorder, levelStart + leftSubtreeSize, levelEnd + <span class="hljs-number">1</span>);<br><br>    root.left = buildTreeFromPreLevel(Arrays.copyOfRange(preorder, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> + leftSubtreeSize), leftLevel);<br>    root.right = buildTreeFromPreLevel(Arrays.copyOfRange(preorder, <span class="hljs-number">1</span> + leftSubtreeSize, preorder.length), rightLevel);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-后序和层序构建"><a href="#5-后序和层序构建" class="headerlink" title="5. 后序和层序构建"></a>5. 后序和层序构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTreeFromPostLevel</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span>[] levelorder)</span> &#123;<br>    <span class="hljs-keyword">return</span> buildTreeFromPostLevel(postorder, levelorder, <span class="hljs-number">0</span>, levelorder.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">buildTreeFromPostLevel</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span>[] levelorder, <span class="hljs-type">int</span> levelStart, <span class="hljs-type">int</span> levelEnd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (levelStart &gt; levelEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(postorder[postorder.length - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">if</span> (levelStart == levelEnd) <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftSubtreeSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> levelStart; i &lt;= levelEnd; i++) &#123;<br>        <span class="hljs-keyword">if</span> (levelorder[i] == postorder[postorder.length - <span class="hljs-number">2</span>]) <span class="hljs-keyword">break</span>;<br>        leftSubtreeSize++;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] leftLevel = Arrays.copyOfRange(levelorder, levelStart, levelStart + leftSubtreeSize);<br>    <span class="hljs-type">int</span>[] rightLevel = Arrays.copyOfRange(levelorder, levelStart + leftSubtreeSize, levelEnd + <span class="hljs-number">1</span>);<br><br>    root.left = buildTreeFromPostLevel(Arrays.copyOfRange(postorder, <span class="hljs-number">0</span>, leftSubtreeSize), leftLevel);<br>    root.right = buildTreeFromPostLevel(Arrays.copyOfRange(postorder, leftSubtreeSize, postorder.length - <span class="hljs-number">1</span>), rightLevel);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树的节点定义"><a href="#线索二叉树的节点定义" class="headerlink" title="线索二叉树的节点定义"></a>线索二叉树的节点定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedTreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ThreadedTreeNode left;<br>    ThreadedTreeNode right;<br>    <span class="hljs-type">boolean</span> isLeftThread;  <span class="hljs-comment">// 标记左指针是否是线索</span><br>    <span class="hljs-type">boolean</span> isRightThread; <span class="hljs-comment">// 标记右指针是否是线索</span><br><br>    ThreadedTreeNode(<span class="hljs-type">int</span> x) &#123;<br>        val = x;<br>        left = <span class="hljs-literal">null</span>;<br>        right = <span class="hljs-literal">null</span>;<br>        isLeftThread = <span class="hljs-literal">false</span>;<br>        isRightThread = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线索二叉树的构建"><a href="#线索二叉树的构建" class="headerlink" title="线索二叉树的构建"></a>线索二叉树的构建</h3><p><strong>（判断当前节点）空的左子树节点指向前驱，（判断前驱）空的右子树节点指向后继</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedBinaryTree</span> &#123;<br>    ThreadedTreeNode root;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 记录前一个访问的节点</span><br><br>    <span class="hljs-comment">// 中序线索化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderThreaded</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        inorderThreaded(node.left);<span class="hljs-comment">//递归，线索化左子树</span><br><br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<br>            node.left = pre; <span class="hljs-comment">// 线索化</span><br>            node.isLeftThread = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.right == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//前驱存在，且前驱右指针为空</span><br>            pre.right = node; <span class="hljs-comment">// 线索化</span><br>            pre.isRightThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        pre = node;<span class="hljs-comment">//在此节点线索化完成后，将pre指向它</span><br><br>        inorderThreaded(node.right);<span class="hljs-comment">//递归，线索化右子树</span><br>    &#125;<br><br>    <span class="hljs-comment">// 前序线索化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorderThreaded</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<br>            node.left = pre; <span class="hljs-comment">// 线索化</span><br>            node.isLeftThread = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.right == <span class="hljs-literal">null</span>) &#123;<br>            pre.right = node; <span class="hljs-comment">// 线索化</span><br>            pre.isRightThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        pre = node;<br><br>        <span class="hljs-keyword">if</span> (!node.isLeftThread) &#123; <span class="hljs-comment">// 遍历左子树</span><br>            preorderThreaded(node.left);<br>        &#125;<br><br>        preorderThreaded(node.right); <span class="hljs-comment">// 遍历右子树</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后序线索化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorderThreaded</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        postorderThreaded(node.left);<br>        postorderThreaded(node.right);<br><br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<br>            node.left = pre; <span class="hljs-comment">// 线索化</span><br>            node.isLeftThread = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.right == <span class="hljs-literal">null</span>) &#123;<br>            pre.right = node; <span class="hljs-comment">// 线索化</span><br>            pre.isRightThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        pre = node;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中序遍历线索二叉树，前驱为左子树最右下节点，后继为右子树的最左下节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>    <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> node;<br><br>    <span class="hljs-comment">// 找到最左的节点</span><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; current.left != <span class="hljs-literal">null</span> &amp;&amp; !current.isLeftThread) &#123;<br>        current = current.left;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>        System.out.print(current.val + <span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-comment">// 如果右指针是线索，直接访问右节点</span><br>        <span class="hljs-keyword">if</span> (current.isRightThread) &#123;<br>            current = current.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            current = current.right;<span class="hljs-comment">//有·右子树，指向它，然后寻找其左子树的最左下节点</span><br><br>            <span class="hljs-comment">// 找到当前节点的左子树的最左节点</span><br>            <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; current.left != <span class="hljs-literal">null</span> &amp;&amp; !current.isLeftThread) &#123;<br>                current = current.left;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 前序遍历线索二叉树</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>    <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> node;<br><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>        System.out.print(current.val + <span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-comment">// 如果左指针是线索，访问左节点</span><br>        <span class="hljs-keyword">if</span> (current.isLeftThread) &#123;<br>            current = current.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            current = current.left;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 后序遍历线索二叉树</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>    <span class="hljs-comment">// 后序遍历在直接遍历的实现中不太直观，通常建议使用栈或其他方法进行实现</span><br>    <span class="hljs-comment">// 如果要实现后序遍历的线索树，建议使用辅助的数据结构来处理</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedBinaryTree</span> &#123;<br>    <span class="hljs-keyword">private</span> ThreadedTreeNode root;<br>    <span class="hljs-keyword">private</span> ThreadedTreeNode pre; <span class="hljs-comment">// 用于线索化时记录前一个节点</span><br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadedBinaryTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.pre = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 中序线索化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderThreaded</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        inorderThreaded(node.left);<br><br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<br>            node.left = pre; <span class="hljs-comment">// 线索化</span><br>            node.isLeftThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.right == <span class="hljs-literal">null</span>) &#123;<br>            pre.right = node; <span class="hljs-comment">// 线索化</span><br>            pre.isRightThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        pre = node;<br><br>        inorderThreaded(node.right);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取中序线索二叉树的第一个节点,(一路向左)</span><br>    <span class="hljs-keyword">public</span> ThreadedTreeNode <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; !current.isLeftThread) &#123;<br>            current = current.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> current;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取给定节点的后继节点</span><br>    <span class="hljs-keyword">public</span> ThreadedTreeNode <span class="hljs-title function_">successor</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node.isRightThread) &#123;<br>            <span class="hljs-keyword">return</span> node.right; <span class="hljs-comment">// 直接返回后继</span><br>        &#125;<br>        <span class="hljs-comment">// 如果不是线索，返回右子树的最左节点</span><br>        node = node.right;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> &amp;&amp; !node.isLeftThread) &#123;<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 中序遍历线索二叉树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> first(); <span class="hljs-comment">// 获取第一个节点</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.val + <span class="hljs-string">&quot; &quot;</span>);<br>            current = successor(current); <span class="hljs-comment">// 获取后继节点</span><br>        &#125;<br>        System.out.println(); <span class="hljs-comment">// 换行</span><br>    &#125;<br><br>    <span class="hljs-comment">// 设置根节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(ThreadedTreeNode root)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedBinaryTree</span> &#123;<br>    <span class="hljs-keyword">private</span> ThreadedTreeNode root;<br>    <span class="hljs-keyword">private</span> ThreadedTreeNode pre; <span class="hljs-comment">// 用于线索化时记录前一个节点</span><br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadedBinaryTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.pre = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 前序线索化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorderThreaded</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<br>            node.left = pre; <span class="hljs-comment">// 线索化</span><br>            node.isLeftThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.right == <span class="hljs-literal">null</span>) &#123;<br>            pre.right = node; <span class="hljs-comment">// 线索化</span><br>            pre.isRightThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        pre = node;<br><br>        <span class="hljs-comment">// 先遍历左子树</span><br>        <span class="hljs-keyword">if</span> (!node.isLeftThread) &#123;<br>            preorderThreaded(node.left);<br>        &#125;<br>        <span class="hljs-comment">// 再遍历右子树</span><br>        preorderThreaded(node.right);<br>    &#125;<br><br>    <span class="hljs-comment">// 后序线索化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorderThreaded</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        postorderThreaded(node.left);<br>        postorderThreaded(node.right);<br><br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span>) &#123;<br>            node.left = pre; <span class="hljs-comment">// 线索化</span><br>            node.isLeftThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.right == <span class="hljs-literal">null</span>) &#123;<br>            pre.right = node; <span class="hljs-comment">// 线索化</span><br>            pre.isRightThread = <span class="hljs-literal">true</span>;<br>        &#125;<br>        pre = node;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取前序线索二叉树的第一个节点</span><br>    <span class="hljs-keyword">public</span> ThreadedTreeNode <span class="hljs-title function_">firstPreorder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 前序的第一个节点就是根节点</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取前序线索二叉树的后继节点</span><br>    <span class="hljs-keyword">public</span> ThreadedTreeNode <span class="hljs-title function_">successorPreorder</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>        <span class="hljs-comment">// 如果左指针是线索，返回左子树的前驱</span><br>        <span class="hljs-keyword">if</span> (!node.isLeftThread) &#123;<br>            <span class="hljs-keyword">return</span> node.left; <span class="hljs-comment">// 返回左子树</span><br>        &#125;<br>        <span class="hljs-comment">// 否则返回右子树</span><br>        <span class="hljs-keyword">return</span> node.right;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取后序线索二叉树的第一个节点</span><br>    <span class="hljs-keyword">public</span> ThreadedTreeNode <span class="hljs-title function_">firstPostorder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; !current.isLeftThread) &#123;<br>            current = current.left; <span class="hljs-comment">// 找到最左的节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> current;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取后序线索二叉树的后继节点</span><br>    <span class="hljs-keyword">public</span> ThreadedTreeNode <span class="hljs-title function_">successorPostorder</span><span class="hljs-params">(ThreadedTreeNode node)</span> &#123;<br>        <span class="hljs-comment">// 如果右指针是线索，返回右子树的后继</span><br>        <span class="hljs-keyword">if</span> (node.isRightThread) &#123;<br>            <span class="hljs-keyword">return</span> node.right;<br>        &#125;<br>        <span class="hljs-comment">// 否则返回右子树的最左节点</span><br>        node = node.right;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> &amp;&amp; !node.isLeftThread) &#123;<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 前序遍历线索二叉树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> firstPreorder(); <span class="hljs-comment">// 获取第一个节点</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.val + <span class="hljs-string">&quot; &quot;</span>);<br>            current = successorPreorder(current); <span class="hljs-comment">// 获取后继节点</span><br>        &#125;<br>        System.out.println(); <span class="hljs-comment">// 换行</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后序遍历线索二叉树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadedTreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> firstPostorder(); <span class="hljs-comment">// 获取第一个节点</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.val + <span class="hljs-string">&quot; &quot;</span>);<br>            current = successorPostorder(current); <span class="hljs-comment">// 获取后继节点</span><br>        &#125;<br>        System.out.println(); <span class="hljs-comment">// 换行</span><br>    &#125;<br><br>    <span class="hljs-comment">// 设置根节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(ThreadedTreeNode root)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h2><h3 id="哈夫曼树的节点定义"><a href="#哈夫曼树的节点定义" class="headerlink" title="哈夫曼树的节点定义"></a>哈夫曼树的节点定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HuffmanNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;HuffmanNode&gt; &#123;<br>    <span class="hljs-type">char</span> character;       <span class="hljs-comment">// 字符</span><br>    <span class="hljs-type">int</span> frequency;        <span class="hljs-comment">// 字符频率(节点权值)</span><br>    HuffmanNode left;     <span class="hljs-comment">// 左子节点</span><br>    HuffmanNode right;    <span class="hljs-comment">// 右子节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HuffmanNode</span><span class="hljs-params">(<span class="hljs-type">char</span> character, <span class="hljs-type">int</span> frequency)</span> &#123;<br>        <span class="hljs-built_in">this</span>.character = character;<br>        <span class="hljs-built_in">this</span>.frequency = frequency;<br>    &#125;<br><br>    <span class="hljs-comment">// 用于优先队列排序</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(HuffmanNode other)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.frequency - other.frequency;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="哈夫曼树的实现"><a href="#哈夫曼树的实现" class="headerlink" title="哈夫曼树的实现"></a>哈夫曼树的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HuffmanTree</span> &#123;<br>    <span class="hljs-keyword">private</span> HuffmanNode root;<br>    <span class="hljs-keyword">private</span> Map&lt;Character, String&gt; huffmanCode; <span class="hljs-comment">// 存储字符到哈夫曼编码的映射</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HuffmanTree</span><span class="hljs-params">()</span> &#123;<br>        huffmanCode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">// 构建哈夫曼树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-type">char</span>[] characters, <span class="hljs-type">int</span>[] frequencies)</span> &#123;<br>        PriorityQueue&lt;HuffmanNode&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 初始化优先队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; characters.length; i++) &#123;<br>            priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HuffmanNode</span>(characters[i], frequencies[i]));<br>        &#125;<br><br>        <span class="hljs-comment">// 构建哈夫曼树</span><br>        <span class="hljs-keyword">while</span> (priorityQueue.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">HuffmanNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> priorityQueue.poll();   <span class="hljs-comment">// 取出最小的两个节点</span><br>            <span class="hljs-type">HuffmanNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> priorityQueue.poll();<br>            <span class="hljs-type">HuffmanNode</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuffmanNode</span>(<span class="hljs-string">&#x27;\0&#x27;</span>, left.frequency + right.frequency); <span class="hljs-comment">// 创建父节点</span><br>            parent.left = left;<br>            parent.right = right;<br>            priorityQueue.offer(parent); <span class="hljs-comment">// 将父节点放回优先队列</span><br>        &#125;<br><br>        root = priorityQueue.poll(); <span class="hljs-comment">// 取出最终的根节点</span><br>        generateHuffmanCodes(root, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 生成哈夫曼编码</span><br>    &#125;<br><br>    <span class="hljs-comment">// 生成哈夫曼编码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateHuffmanCodes</span><span class="hljs-params">(HuffmanNode node, String code)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>            huffmanCode.put(node.character, code); <span class="hljs-comment">// 叶子节点</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        generateHuffmanCodes(node.left, code + <span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-comment">// 左子树编码为 0</span><br>        generateHuffmanCodes(node.right, code + <span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">// 右子树编码为 1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取哈夫曼编码</span><br>    <span class="hljs-keyword">public</span> Map&lt;Character, String&gt; <span class="hljs-title function_">getHuffmanCodes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> huffmanCode;<br>    &#125;<br><br>    <span class="hljs-comment">// 解码哈夫曼编码</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decode</span><span class="hljs-params">(String encoded)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">decoded</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">HuffmanNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> bit : encoded.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (bit == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                current = current.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                current = current.right;<br>            &#125;<br><br>            <span class="hljs-comment">// 到达叶子节点</span><br>            <span class="hljs-keyword">if</span> (current.left == <span class="hljs-literal">null</span> &amp;&amp; current.right == <span class="hljs-literal">null</span>) &#123;<br>                decoded.append(current.character);<br>                current = root; <span class="hljs-comment">// 回到根节点</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> decoded.toString();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="哈夫曼树的使用"><a href="#哈夫曼树的使用" class="headerlink" title="哈夫曼树的使用"></a>哈夫曼树的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 示例字符及其频率</span><br>        <span class="hljs-type">char</span>[] characters = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>&#125;;<br>        <span class="hljs-type">int</span>[] frequencies = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">45</span>&#125;;<br><br>        <span class="hljs-comment">// 构建哈夫曼树</span><br>        <span class="hljs-type">HuffmanTree</span> <span class="hljs-variable">huffmanTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuffmanTree</span>();<br>        huffmanTree.buildHuffmanTree(characters, frequencies);<br><br>        <span class="hljs-comment">// 获取哈夫曼编码</span><br>        Map&lt;Character, String&gt; huffmanCodes = huffmanTree.getHuffmanCodes();<br>        System.out.println(<span class="hljs-string">&quot;哈夫曼编码：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, String&gt; entry : huffmanCodes.entrySet()) &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">// 示例编码</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">encodedString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : characters) &#123;<br>            encodedString.append(huffmanCodes.get(c));<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;编码字符串：&quot;</span> + encodedString.toString());<br><br>        <span class="hljs-comment">// 解码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">decodedString</span> <span class="hljs-operator">=</span> huffmanTree.decode(encodedString.toString());<br>        System.out.println(<span class="hljs-string">&quot;解码字符串：&quot;</span> + decodedString);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. 数组排序</title>
    <link href="/hexo-blog/2024/11/09/2.%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
    <url>/hexo-blog/2024/11/09/2.%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h1><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序（Bubble-sort）"><a href="#冒泡排序（Bubble-sort）" class="headerlink" title="冒泡排序（Bubble sort）"></a>冒泡排序（Bubble sort）</h3><ul><li>步骤：<ol><li>第一个for循环:进行n-1躺排序</li><li>创建标记，第二个for循环：进行每趟的排序(从<code>0~n-1-i</code>)<ol><li>判断条件。。。(注意使用标记判断是否需要提前结束)</li></ol></li></ol></li></ul><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp" alt="动图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//n个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<span class="hljs-comment">//总共进行n-1躺</span><br><span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//本趟的标记</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n<span class="hljs-number">-1</span>-i;j++)&#123;<span class="hljs-comment">//每趟对比次数为n-i,</span><br><span class="hljs-comment">//注意比较的是j和j+1，所以判断需要满足j+1的存在(j&lt;n-1-i)</span><br><span class="hljs-keyword">if</span>(a[j]&gt;a[j<span class="hljs-number">+1</span>])&#123;<br><span class="hljs-built_in">swap</span>(&amp;a[j],&amp;a[j<span class="hljs-number">+1</span>]);<br>falg=<span class="hljs-number">1</span>;<span class="hljs-comment">//表示本躺有交换元素</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果某躺没有交换元素，则结束排序</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  共n-1躺，一趟结束确定一个数的位置</span><br><span class="hljs-comment">  每趟：走n-1-i步</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>特点：</p><ol><li>稳定性：稳定</li><li>时间复杂度：<code>O(N^2)</code></li><li>空间复杂度：<code>O(1)</code></li></ol><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="C:\Users\85366\AppData\Roaming\Typora\typora-user-images\image-20230307225528674.png" alt=" "></p><p>步骤：</p><ol><li>确定分界点<strong>x</strong>：<code>q[l]   q[(l+r)/2]   q[k] (.l为左边界，r为右边界，k表示在区间内的随机值)</code></li><li>调整区间：<strong>让左边区间的数都小于等于x,右边区间的数都大于等于x</strong></li><li>递归：递归处理左右两段</li></ol><p>调整区间的常用方法：</p><ul><li><p>方法1：</p><ol><li><p>创建两个额外的数组<code>a[ ]   b[ ]</code></p></li><li><p>扫描区间<code>q[l ~ r]</code>中的每个数</p><ul><li>若<code>q[i]&lt;=x</code>，则将x插入<code>a[]</code>中</li><li>若<code>q[i]&gt;x</code>，则将x插入<code>b[ ] </code>中</li></ul></li><li><p><code>a[ ]-&gt; q[ ]   b[ ]-&gt;q[ ]</code></p></li></ol></li></ul><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/image-20230307230131170.png" alt="image-20230307230131170"></p><ul><li>方法2：<ol><li>两个指针<code>i , j</code>分别指向端点<code>l , r</code></li><li><code>i&lt;=x</code>则<code>i</code>向后比（++i）,直到<code>i&gt;x</code>则停止，比较<code>j</code></li><li><code>j&gt;=x</code>，则·<code>j</code>向前比(- -j),直到<code>j&lt;x</code>则停止，此时交换<code>i,j</code>所对应的数值(<code>swap( q[i] , q[j])</code>)，然后<code>++i  --j</code></li><li>然后循环2,3步骤，直到<code>i,j</code>相遇停止</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快排的递归版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果没有元素或只有一个元素，则返回</span><br><br><span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r<span class="hljs-number">+1</span>,x=q[l+r&gt;&gt;<span class="hljs-number">1</span>];<span class="hljs-comment">//x取中间结点，i,j初始指向空指针</span><br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(q[i]&lt;x);<span class="hljs-comment">//循环停止到q[i]&gt;=x的位置</span><br><span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(q[j]&gt;x);<span class="hljs-comment">//循环停止到q[i]&lt;=x的位置</span><br><span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(q[i],q[j]);<span class="hljs-comment">//判断交换元素</span><br>&#125;<br><span class="hljs-built_in">quick_sort</span>(q,l,j),<span class="hljs-built_in">quick_sort</span>(q,j<span class="hljs-number">+1</span>,r);<span class="hljs-comment">//递归处理</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br><span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,q[i]);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>基本思想：每次从待排序的数据元素中选出最小（最大）的一个元素，存放在序列的起始位置，直到全部待排序元素全部排完</li></ul><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><ul><li>基本思想:</li></ul><ol><li>在元素集合中选出关键字最小的元素</li><li>若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个(第一个)元素交换</li><li>然后重复上述操作，直到全部都排完</li></ol><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp" alt="动图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//begin指向左边有序序列的下一个元素的下标(找最小值)</span><br>    <span class="hljs-comment">//end指向右边有序序列(从右向左)的下一个元素的下标(最大值)</span><br><span class="hljs-type">int</span> begin=<span class="hljs-number">0</span>,end=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//元素下标</span><br><span class="hljs-keyword">while</span>(begin&lt;end)&#123;<br><span class="hljs-type">int</span> maxi=begin,mini=begin;<br><span class="hljs-comment">//选数，同时选出最大的和最小的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=end;i++)&#123;<span class="hljs-comment">//从待排序的位置开始</span><br><span class="hljs-keyword">if</span>(a[maxi]&lt;a[i])&#123;<span class="hljs-comment">//选出最大元素的下标</span><br>maxi=i;<br>&#125;<br><span class="hljs-keyword">if</span>(a[mini]&gt;a[i])&#123;<span class="hljs-comment">//选出最小元素的下标</span><br>mini=i;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(&amp;a[mini],&amp;a[begin]);<br><span class="hljs-comment">//如果刚好最大值在begin位置，则要更新maxi</span><br><span class="hljs-keyword">if</span>(maxi==begin)maxi=mini;<br><span class="hljs-built_in">swap</span>(&amp;a[maxi],&amp;a[end]);<br><span class="hljs-comment">//更新指针</span><br>        begin++;<br>end--;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//注意：在一趟中直接排好最大和最小值的位置</span><br></code></pre></td></tr></table></figure><ul><li>特点：<ol><li>时间复杂度:<code>O(N^2)</code></li><li>空间复杂度:<code>O(N)</code></li><li>稳定性：不稳定</li></ol></li></ul><h3 id="堆排序-Heapsort"><a href="#堆排序-Heapsort" class="headerlink" title="堆排序(Heapsort)"></a>堆排序(Heapsort)</h3><ul><li>基本思想</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">是指利用堆积树<span class="hljs-comment">(堆)</span>这种数据结构所设计的一种排序算法，<br></code></pre></td></tr></table></figure><p><strong>升序建立大根堆，降序建立小根堆</strong></p><ul><li>步骤<ol><li>建堆:  （升序：建大堆，降序：建小堆）</li><li>利用堆删除思想来进行排序</li></ol></li></ul><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/9a41c7a4e2b84cd695b9d7b1109ce5e8.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//向下调整算法(将小的节点不断下坠)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AdjustDwon</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> parent)</span></span>&#123;<br><span class="hljs-comment">//n表示节点数,parent表示当前向下调整的节点</span><br><span class="hljs-type">int</span> child=parent*<span class="hljs-number">2</span><span class="hljs-number">+1</span>;<span class="hljs-comment">//通过父母找到孩子节点(左孩子)</span><br><span class="hljs-keyword">while</span>(child&lt;n)&#123;<span class="hljs-comment">//若孩子节点存在</span><br><span class="hljs-keyword">if</span>(child<span class="hljs-number">+1</span>&lt;n&amp;&amp;a[child]&lt;a[child<span class="hljs-number">+1</span>])&#123;<span class="hljs-comment">//建立升序大堆（下坠大的）</span><br><span class="hljs-comment">//若右孩子存在，且大于左孩子节点</span><br>child++;<span class="hljs-comment">//指向大的孩子节点(右孩子)</span><br>&#125;<span class="hljs-keyword">if</span>(a[child]&gt;a[parent])&#123;<span class="hljs-comment">//如果最大的孩子节点大于父节点</span><br><span class="hljs-built_in">swap</span>(&amp;a[child],&amp;a[parent]);<span class="hljs-comment">//交换节点值(将小的换下来)</span><br>parent=child;<span class="hljs-comment">//更新下次比较的节点</span><br>child=parent*<span class="hljs-number">2</span><span class="hljs-number">+1</span>;<br>&#125;<span class="hljs-keyword">else</span><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-comment">//建堆</span><br>    <span class="hljs-comment">//向下调整建堆，从倒数第一个非叶子节点（最后一个节点的父亲）开始调整，逐个向下调整，只需要遍历除叶子节点以外的节点就可以了</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(n<span class="hljs-number">-2</span>)/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i++)&#123;<span class="hljs-comment">//i=n-1,下标为=n-1-1=n-2 </span><br><span class="hljs-built_in">AdjustDwon</span>(a,n,i);<br>&#125;<br><br><span class="hljs-comment">//排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-built_in">swap</span>(&amp;a[<span class="hljs-number">0</span>],&amp;a[n-i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//把大的放到最后</span><br><span class="hljs-built_in">AdjustDwon</span>(a,n-i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//重新调整堆</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Captain_ldx/article/details/127159474">(135条消息) 【数据结构初阶】简析堆排序_Captain-Lin的博客-CSDN博客</a></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ul><li>基本思想：</li></ul><p>把待排序的记录按其关键码值的大小逐个插入到一个已经排序好的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列</p><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/8b433f6eb4c14089b965e2513f023f62.gif" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入排序</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> end=i;<span class="hljs-comment">//分界点(有序 | 无序)</span><br><span class="hljs-type">int</span> tem=a[end<span class="hljs-number">+1</span>];<span class="hljs-comment">//保存后一个值</span><br><span class="hljs-keyword">while</span>(end&gt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(tem&lt;a[end])&#123;<span class="hljs-comment">//后一个值小，前面的值往后移</span><br>a[end<span class="hljs-number">+1</span>]=a[end];<br>end--;<br>&#125;<span class="hljs-keyword">else</span><span class="hljs-keyword">break</span>;<br>&#125;<br>a[end<span class="hljs-number">+1</span>]=tem;<span class="hljs-comment">//把小的值插入到属于它的位置</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//写法2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//从第二个元素开始遍历无序序列</span><br><span class="hljs-type">int</span> temp=a[i];<span class="hljs-comment">//临时保存将要排序的元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;temp&lt;a[j]&amp;&amp;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>a[j<span class="hljs-number">+1</span>]=a[j];<span class="hljs-comment">//有序元素序列中当前元素时，将该元素后移</span><br>&#125;<br>a[j<span class="hljs-number">+1</span>]=temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>特点：<ol><li>元素集合越接近有序，直接插入排序算法的时间效率越高</li><li>时间复杂度：<code>O(N^2)</code></li><li>空间复杂度：<code>O(1)</code></li><li>稳点性：稳定</li></ol></li></ul><h3 id="希尔排序-缩小增量排序"><a href="#希尔排序-缩小增量排序" class="headerlink" title="希尔排序(缩小增量排序)"></a>希尔排序(缩小增量排序)</h3><ul><li>基本思想：</li></ul><p>先选一个整数gap，把待排序文件中所有记录分成gap个组，所有距离为gap的记录分在同一个组内，并为每个组内的记录进行排序(使用直接插入排序)</p><p>然后重复上述分组和排序的工作，当所有记录在统一组内拍好序</p><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/4ca3874e324a4a7fbb032db0d7362e82.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/440cf4e874e14521ad23160b6b824a60.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/aed189d1c5554a29a0f5159908dcb652.jpg" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//希尔排序</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-type">int</span> gap=n;<br><span class="hljs-keyword">while</span>(gap&gt;<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//每次对gap折半操作</span><br>gap=gap/<span class="hljs-number">2</span>;<br><span class="hljs-comment">//单趟排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-gap;++i)&#123;<br><span class="hljs-type">int</span> end=i;<br><span class="hljs-type">int</span> tem=a[end+gap];<span class="hljs-comment">//保存第后gap的值</span><br><span class="hljs-keyword">while</span>(end&gt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(tem&lt;a[end])&#123;<span class="hljs-comment">//后gap的值小，前面的值往后移</span><br>a[end+gap]=a[end];<br>end-=gap;<br>&#125;<span class="hljs-keyword">else</span><span class="hljs-keyword">break</span>;<br>&#125;<br>a[end+gap]=tem;<span class="hljs-comment">//把小的值插到属于它的位置</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//实现二：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-type">int</span> dk;<span class="hljs-comment">//定义增量dk</span><br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(dk=n/<span class="hljs-number">2</span>;dk&gt;=<span class="hljs-number">1</span>;dk=dk/<span class="hljs-number">2</span>)&#123;<br><span class="hljs-comment">//将各个子表的直接插入排序分解，合并为一个循环</span><br><span class="hljs-comment">//一次循环过程仅按顺序处理一个元素</span><br><br><span class="hljs-comment">//从第i个子表的第2个元素开始，第2次循环进行第2个子表的第2个元素</span><br><span class="hljs-keyword">for</span>(i=dk<span class="hljs-number">+1</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;a[i-dk])&#123;<span class="hljs-comment">//仅在当前元素无序时进行排序</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>a[<span class="hljs-number">0</span>]=a[i];<span class="hljs-comment">//a[0]不是哨兵，仅暂存元素</span><br><span class="hljs-keyword">for</span>(j=i-dk;j&gt;=<span class="hljs-number">0</span>&amp;&amp;a[<span class="hljs-number">0</span>]&lt;a[j];j-=dk)&#123;<span class="hljs-comment">//从当前子表的前一个增量开始</span><br>a[j+dk]=a[j];<br>&#125;<br>a[j+dk]=a[<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-comment">// C实现 （数组从下标为0开始）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">int</span> gap, i, j;<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-keyword">for</span> (gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> (i = gap; i &lt; len; i++) &#123;<br>            temp = arr[i];<br>            <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)<br>                arr[j + gap] = arr[j];<br>            arr[j + gap] = temp;<br>        &#125;<br>&#125;<br><br><br><br><br><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  基本思想：</span><br><span class="hljs-comment">  先将待排序表分割成若干形如[i,i+d,i+2d,...,i+kd]的特殊子表</span><br><span class="hljs-comment">  即把相隔某个增量的记录组成一个子表，对各个子表进行直接插入排序</span><br><span class="hljs-comment">  当整个表中的元素已基本有序时，再对全体记录进行一次直接插入排序</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>特点：<ol><li>时间复杂度:<code>O(N^1.3)</code>,最坏O(N^2)</li><li>空间复杂度:<code>O(1)</code></li><li>稳定性：不稳定</li></ol></li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li><p>算法思想：分治</p></li><li><p>步骤：</p><ol><li>确定分界点:mid&#x3D;(l+r)&#x2F;2</li><li>递归排序左边和右边</li><li>归并两个有序数组合并为一个（使用双指针）</li></ol></li></ul><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" alt="img"></p><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_r.jpg" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> namespece std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> a[N],temp[N];<span class="hljs-comment">//用来暂存</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br><span class="hljs-keyword">if</span>(left&gt;right)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果只有一个或者没有元素则返回</span><br><br><span class="hljs-type">int</span> mid=left+right&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(q,left,mid),<span class="hljs-built_in">merge_sort</span>(q,mid<span class="hljs-number">+1</span>,right);<span class="hljs-comment">//递归子问题</span><br><br>         <span class="hljs-comment">//将相邻的左右数组进行排序</span><br><span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=left,j=mid<span class="hljs-number">+1</span>;<span class="hljs-comment">//双指针对两个有序数组进行排序，结果存在temp[]</span><br><span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;<br><span class="hljs-keyword">if</span>(q[i]&gt;q[j])temp[k++]=q[i++];<br><span class="hljs-keyword">else</span>temp[k++]=q[j++];<br>&#125;<br><span class="hljs-keyword">while</span>(i&lt;=mid)temp[k++]=q[i++];<br><span class="hljs-keyword">while</span>(j&lt;=right)temp[k++]=q[j++];<br><br><span class="hljs-comment">//将temp元素放回q[]中</span><br><span class="hljs-keyword">for</span>(i=left,j=<span class="hljs-number">0</span>;i&lt;=right;i++,j++)q[i]=temp[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br><span class="hljs-built_in">merge_sort</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><ul><li><p>特点：</p><ol><li>时间复杂度：<code>O(N*logN)</code></li><li>空间复杂度：<code>O(N)</code></li><li>稳定性：稳定</li></ol></li><li><p>迭代法：</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一个位置</li><li>重复步骤<code>3</code>直到某一个指针到达序列尾</li><li>将另一个序列剩下的所有元素直接复制到合并序列尾</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure></li></ul><h2 id="非比较排序（计数排序）"><a href="#非比较排序（计数排序）" class="headerlink" title="非比较排序（计数排序）"></a>非比较排序（计数排序）</h2><ul><li><strong>计数排序</strong>又称为<strong>鸽巢原理</strong>，是对哈希直接定址法的变形应用</li><li>算法思想：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">使用一个额外的数组<br></code></pre></td></tr></table></figure><p><code>counts</code>其中<code>counts[i]</code>表示原数组<code>arr</code>中值等于<code>i</code>的元素个数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">然后根据数组<br></code></pre></td></tr></table></figure><p><code>counts</code>来将<code>arr</code>中的元素排到正确的位置</p><ul><li>步骤：<ol><li>统计相同元素出现次数</li><li>根据统计的结果将序列会受到原来的序列中</li></ol></li></ul><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/cd4c22205b8f458b899b933e7a1439d9.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/6c9e7a2495114f5eb15eaaaec3c51f8f.gif#pic_center" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计数排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-type">int</span> max,min;<br>max=min=a[<span class="hljs-number">0</span>];<br><span class="hljs-comment">//找出最大最小值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(max&lt;a[i])max=a[i];<br><span class="hljs-keyword">if</span>(min&gt;a[i])min=a[i];<br>&#125;<br><br><span class="hljs-comment">//开辟对应大小的空间</span><br><span class="hljs-type">int</span> *count=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*(max-min<span class="hljs-number">+1</span>));<br><span class="hljs-keyword">if</span>(count==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-comment">//perror()用来将上个函数发生错误的原因输出到标准设备(stder)</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;malloc fail\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//将辅助数组中的值初始化为0</span><br><span class="hljs-built_in">memset</span>(count,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*(max-min<span class="hljs-number">+1</span>));<br><br><span class="hljs-comment">//统计每个数出现的次数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>count[a[i]-min]++;<br>&#125;<br><br><span class="hljs-comment">//开始copy回原数组</span><br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(j&lt;n)&#123;<br><span class="hljs-keyword">if</span>(count[i]==<span class="hljs-number">0</span>)&#123;<br>i++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>a[j++]=i+min;<br>count[i]--;<br>&#125;<br><span class="hljs-built_in">free</span>(count);<br>&#125;<br><br><span class="hljs-comment">//void *memset(void *str,int c,size_t n)</span><br><span class="hljs-comment">//复制字符c(一个无符号字符)到参数str所指向的字符串的前n个字符</span><br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul><li>基本思想：</li></ul><p>将未排序数组分到若干个<code>桶</code>中，每个桶的元素再进行单独排序</p><ul><li>算法步骤：<ol><li>根据原始数组的值域范围，将数组划分为<code>k</code>个相同大小的子区间，美国区间称为一个桶</li><li>遍历原始数组元素，将每个元素装入对应区间的桶中</li><li>对每个原始数组元素单独排序(使用插入排序，归并排序，快速排序等算法)</li><li>最后按照区间顺序将桶内的元素合并起来，完成排序</li></ol></li></ul><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/20211020155244.png" alt="img"></p><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/20211020155314.png" alt="img"></p><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/20211020155335.png" alt="img"></p><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/20210202113809490.gif" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-comment">//模拟生产整数随机数</span><br><br><span class="hljs-comment">//传入空数组arr[]以及它的长度len，填入[min,max]区间的随机数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRand</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> min,<span class="hljs-type">int</span> max)</span></span>&#123;<br>std::default_random_engine e;<br>e.<span class="hljs-built_in">seed</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br><span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(min,max)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)arr[i]=<span class="hljs-built_in">u</span>(e);<br>&#125;<br><br><br><br><br><br><span class="hljs-comment">//桶排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span></span>&#123;<br><span class="hljs-comment">//确定最大值和最小值</span><br><span class="hljs-type">int</span> max=INT_MIN,min=INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br><span class="hljs-keyword">if</span>(arr[i]&gt;max)max=arr[i];<br><span class="hljs-keyword">if</span>(arr[i]&lt;min)min=arr[i];<br>&#125;<br><br><span class="hljs-comment">//生成桶数组</span><br><span class="hljs-comment">//设置最小的值为索引0，每个桶间隔为1</span><br><span class="hljs-type">int</span> bucketLen=max-min<span class="hljs-number">+1</span>;<br><br><span class="hljs-comment">//初始化桶</span><br><span class="hljs-type">int</span> bucket[bucketLen];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;bucketLen;i++)bucket[i]=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//放入桶中</span><br><span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>index=arr[i]-min;<br>bucket[index]+=<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//替换原序列</span><br><span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;bucketLen;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=start;j&lt;start+bucket[i];j++)&#123;<br>arr[j]=min+i;<br>&#125;<br>start+=bucket[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">index=arr[i]-min;把最小值放到桶的第一个数组下标中</span><br><span class="hljs-comment">bucket[index]+=1;</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul><li>算法思想：</li></ul><p>将整数按位数切割成不同的数字,然后按每个位数分别比较进行排序</p><ul><li>算法步骤：</li></ul><p>可以采用<code>最低位优先法(Least Significant Digit First)</code>或者<code>最高位优先法(Most Significat DIgit first)</code></p><p>以最低位优先法为例：</p><ol><li>遍历数组元素，获取数组最大值元素，并取得位数</li><li>定义一个长度为<code>10</code>的桶<code>buckets</code>，分为代表<code>1~9</code>这<code>10</code>个数字</li><li>以个位元素为索引，根据数组元素各位上的值，将数组元素存入对应数字的桶中</li><li>清空原始数组，并从桶中依次取出对应原始，重新加入到原始数组中</li><li>之后分为以十位，百位，…，最大值元素的最高位为索引，根据元素对应位上的数字，存入对应数字的桶中。合并数组，完成排序</li></ol><p><img src="https://fandecade.oss-cn-hangzhou.aliyuncs.com/20220818144208.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Radix_Sort</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(<span class="hljs-type">int</span> data[],<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-comment">//辅助函数，求数据的最大位</span><br><span class="hljs-type">int</span> maxData=data[<span class="hljs-number">0</span>];<span class="hljs-comment">//最大值</span><br><br><span class="hljs-comment">//先求出最大值，再求其位数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br><span class="hljs-keyword">if</span>(maxData&lt;data[i])maxData=data[i];<br>&#125;<br><br><span class="hljs-type">int</span> d=<span class="hljs-number">1</span>,p=<span class="hljs-number">10</span>;<span class="hljs-comment">//d表示位数</span><br><span class="hljs-keyword">while</span>(maxData&gt;=p)&#123;<br>maxData/=<span class="hljs-number">10</span>;<br>++d;<br>&#125;<br><span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-comment">//基数排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RadixSort</span><span class="hljs-params">(<span class="hljs-type">int</span> data[],<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-type">int</span> d=<span class="hljs-built_in">maxbit</span>(data,n);<span class="hljs-comment">//计算最大值的位数</span><br><span class="hljs-type">int</span> *tmp=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<span class="hljs-comment">//用来临时排序</span><br><span class="hljs-type">int</span> *count=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//10进制数字0~9(桶)</span><br><br><span class="hljs-type">int</span> i,j,k;<br><span class="hljs-type">int</span> radix=<span class="hljs-number">1</span>;<span class="hljs-comment">//个位、十位...</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=d;i++)&#123;<span class="hljs-comment">//进行d次排序</span><br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++)count[j]=<span class="hljs-number">0</span>;<span class="hljs-comment">//每次分配前清空计数器</span><br><br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>k=(data[j]/radix)%<span class="hljs-number">10</span>;<span class="hljs-comment">//拿出每位中的数</span><br>count[k]++;<span class="hljs-comment">//统计每个桶中的记录数</span><br>&#125;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">10</span>;j++)&#123;<br><span class="hljs-comment">//将tmp中的位置依次分配给每个桶</span><br>count[j]=count[j<span class="hljs-number">-1</span>]+count[j];<br>&#125;<br><span class="hljs-keyword">for</span>(j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span><br>k=(data[j]/radix)%<span class="hljs-number">10</span>;<span class="hljs-comment">//确定元素当前位的值</span><br>tmp[count[k]<span class="hljs-number">-1</span>]=data[j];<span class="hljs-comment">//根据值将其放入tmp数组中，减一(下标为0开始）)</span><br>count[k]--;<br>&#125;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<span class="hljs-comment">//将临时数组中的内容复制到data中</span><br>data[j]=tmp[j];<br>radix=radix*<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">delete</span>[]tmp;<br><span class="hljs-keyword">delete</span> []count;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相关注意点：</p><p>具体来说，对于每一个位数，我们需要对输入中的数字进行计数排序。而计数排序的核心就是统计每一个桶中元素的数量，然后将其分配给下一个桶。上述代码中的 <code>count[j]=count[j-1]+count[j]</code> 就是在进行这个分配操作，它的具体含义如下</p><p><code>count[j]</code> 表示将输入序列中小于等于 <code>j</code> 的数字分配到该桶中的数量。<br>- 当 <code>j=0</code> 时，我们不需要进行分配操作，因此 <code>count[0]</code> 应该为 0。<br>- 当 <code>j&gt;0</code> 时，<code>count[j-1]</code> 表示前面的桶已经存放了小于等于 <code>j-1</code> 的数字的数量。因此， <code>count[j-1]+count[j]</code> 就是当前桶中存放小于等于 <code>j</code> 的数字的数量，也就是当前桶中元素的开始位置。这一步的目的是让下一个桶中存放的元素的位置从上一个桶中存放的元素之后开始。</p><p>通过这样的分配操作，在每个桶中存放的数字就会按照当前位上的数值大小有序排列，而且保证了相同的数字会被放置到同一个桶中。最后我们将每个桶中的数字按照顺序合并起来，就可以得到排好序的序列。</p><ol start="2"><li><p>假设现在我们有一个数组 <code>arr=[3,2,8,4,6,1,5,7]</code>，我们需要对它进行基数排序。我们以个位数为第一关键字进行排序，每个数的个位数的取值范围是 0～9，因此我们需要创建 10 个桶来存放数字。</p><p>首先，我们将 <code>arr</code> 数组中的所有数字按照个位数的大小放到对应的桶中。通过遍历数组，我们可以得到数字 3、2、8、4、6、1、5 和 7 八个数字，他们的个位数分别为 3、2、8、4、6、1、5 和 7，那么我们可以在第 3、2、8、4、6、1、5 和 7 号桶中分别加入这些数字。此时各个桶中的数字分别为：</p><p>- 桶 0：（空）<br>- 桶 1：1<br>- 桶 2：2<br>- 桶 3：3<br>- 桶 4：4<br>- 桶 5：5<br>- 桶 6：6<br>- 桶 7：7<br>- 桶 8：8<br>- 桶 9：（空）</p><p>然后，我们需要将这些数字按照桶的顺序进行合并。为此，我们可以借助上述代码中的 <code>count</code> 数组。假设此时 <code>count</code> 数组的值为 <code>[0, 1, 2, 2, 3, 4, 5, 6, 7, 7]</code>，那么我们可以得到：</p><p>- 在第 0 个桶中的数字在排序后应该放在新数组的第 0 个位置，因此新数组中位置 0 放入的数应该是数值为 1 的数字；<br>- 在第 1 个桶中的数字在排序后应该放在新数组的第 1 个位置或者之后，因此新数组中位置 1 放入的数应该是数值为 2 的数字；<br>- 在第 2 个桶中的数字在排序后应该放在新数组的第 2 个位置或者之后，因此新数组中位置 2 和位置 3 放入的数应该是数值为 3 的数字；<br>- …</p><p>以此类推，最终得到排好序的数组 <code>arr=[1, 2, 3, 4, 5, 6, 7, 8]</code>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>DS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 栈、队列、数组</title>
    <link href="/hexo-blog/2024/11/09/1.%20%E6%A0%88-%E9%98%9F%E5%88%97/"/>
    <url>/hexo-blog/2024/11/09/1.%20%E6%A0%88-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈、队列、数组"><a href="#栈、队列、数组" class="headerlink" title="栈、队列、数组"></a>栈、队列、数组</h1><h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><h3 id="1-栈的顺序存储结构"><a href="#1-栈的顺序存储结构" class="headerlink" title="1. 栈的顺序存储结构"></a>1. 栈的顺序存储结构</h3><blockquote><p>顺序栈（Stack）是基于数组的栈实现。栈是一种遵循后进先出（LIFO，Last In, First Out）原则的数据结构，其中元素的插入和删除只能在栈顶进行。顺序栈通过数组来存储元素，可以通过数组的下标来模拟栈顶的位置。</p><h3 id="1-顺序栈的基本操作"><a href="#1-顺序栈的基本操作" class="headerlink" title="1. 顺序栈的基本操作"></a>1. 顺序栈的基本操作</h3><ul><li>**压栈 (Push)**：将一个元素添加到栈顶。</li><li>**弹栈 (Pop)**：移除栈顶的元素。</li><li>**栈顶元素 (Peek&#x2F;Top)**：获取栈顶的元素，但不移除它。</li><li>**判断栈是否为空 (isEmpty)**：检查栈是否为空。</li><li>**获取栈的大小 (size)**：获取栈中元素的数量。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Object[] stackArray; <span class="hljs-comment">// 存储栈元素的数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> top;             <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;        <span class="hljs-comment">// 栈的容量</span><br><br>    <span class="hljs-comment">// 构造函数，初始化栈的容量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        stackArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>        top = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 栈为空时，栈顶指针为-1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断栈是否已满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == capacity - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈的大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 压栈操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T element)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;栈满，无法压栈&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        stackArray[++top] = element; <span class="hljs-comment">// 将元素放到栈顶，并更新栈顶指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 弹栈操作</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;栈空，无法弹栈&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> (T) stackArray[top]; <span class="hljs-comment">// 获取栈顶元素</span><br>        stackArray[top--] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 移除栈顶元素，并更新栈顶指针</span><br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈顶元素但不弹出</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;栈空，没有栈顶元素&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) stackArray[top]; <span class="hljs-comment">// 返回栈顶元素</span><br>    &#125;<br><br>    <span class="hljs-comment">// 打印栈的内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;栈空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.print(<span class="hljs-string">&quot;栈元素：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= top; i++) &#123;<br>            System.out.print(stackArray[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-栈的链式存储结构"><a href="#2-栈的链式存储结构" class="headerlink" title="2. 栈的链式存储结构"></a>2. 栈的链式存储结构</h3><blockquote><p>链栈（Linked Stack）是一种基于链表实现的栈结构。与顺序栈不同，链栈不需要预设容量限制，而是通过节点动态地进行扩展。当需要压栈时，只需在链表的头部插入新节点；当弹栈时，只需从链表头部移除节点。</p><h3 id="链栈的基本操作："><a href="#链栈的基本操作：" class="headerlink" title="链栈的基本操作："></a>链栈的基本操作：</h3><ul><li>**压栈 (Push)**：将一个元素添加到栈顶（链表头部）。</li><li>**弹栈 (Pop)**：移除栈顶元素（链表头部）。</li><li>**栈顶元素 (Peek&#x2F;Top)**：获取栈顶的元素但不移除它。</li><li>**判断栈是否为空 (isEmpty)**：检查栈是否为空。</li><li>**获取栈的大小 (size)**：获取栈中元素的数量。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    T data;       <span class="hljs-comment">// 存储数据</span><br>    Node&lt;T&gt; next; <span class="hljs-comment">// 指向下一个节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; top;  <span class="hljs-comment">// 栈顶节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;     <span class="hljs-comment">// 栈的大小</span><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedStack</span><span class="hljs-params">()</span> &#123;<br>        top = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 初始时栈为空</span><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈的大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">// 压栈操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T element)</span> &#123;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(element);<br>        newNode.next = top; <span class="hljs-comment">// 新节点指向原栈顶</span><br>        top = newNode;      <span class="hljs-comment">// 栈顶指针指向新节点</span><br>        size++;             <span class="hljs-comment">// 栈大小加 1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 弹栈操作</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;栈空，无法弹栈&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> top.data; <span class="hljs-comment">// 获取栈顶元素</span><br>        top = top.next;       <span class="hljs-comment">// 更新栈顶指针</span><br>        size--;               <span class="hljs-comment">// 栈大小减 1</span><br>        <span class="hljs-keyword">return</span> element;       <span class="hljs-comment">// 返回弹出的元素</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈顶元素但不弹出</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;栈空，没有栈顶元素&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> top.data; <span class="hljs-comment">// 返回栈顶元素</span><br>    &#125;<br><br>    <span class="hljs-comment">// 打印栈的内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;栈空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node&lt;T&gt; current = top;<br>        System.out.print(<span class="hljs-string">&quot;栈元素：&quot;</span>);<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            current = current.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3. 栈的应用"></a>3. 栈的应用</h3><h4 id="a-括号匹配"><a href="#a-括号匹配" class="headerlink" title="a. 括号匹配"></a>a. 括号匹配</h4><blockquote><p>栈是许多算法中常用的数据结构，特别适合解决括号匹配等问题。在括号匹配问题中，要求检查一组括号是否成对出现，并且括号的顺序是否正确。例如：</p><ul><li><code>()</code>、<code>&#123;[]&#125;</code> 和 <code>([])</code> 是有效的括号序列。</li><li><code>(&#123;[)]&#125;</code>、<code>[&#123;(&#125;)]</code> 和 <code>((())</code> 是无效的括号序列。</li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在括号匹配问题中，我们通常会遇到以下两种操作：</p><ol><li>**压栈 (Push)**：当遇到一个左括号（<code>(</code>、<code>&#123;</code> 或 <code>[</code>），将其压入栈中。</li><li>**弹栈 (Pop)**：当遇到一个右括号（<code>)</code>、<code>&#125;</code> 或 <code>]</code>），我们检查栈顶是否为匹配的左括号。如果是，则弹出栈顶元素；如果不是，说明括号不匹配。</li></ol><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>创建一个空栈。</li><li>遍历给定的括号字符串：<ul><li>当遇到左括号时，压入栈。</li><li>当遇到右括号时，检查栈是否为空以及栈顶元素是否匹配。如果不匹配，则返回 <code>false</code>。</li></ul></li><li>最后，如果栈为空，则所有的括号都匹配，返回 <code>true</code>；否则返回 <code>false</code>。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    T data;       <span class="hljs-comment">// 存储数据</span><br>    Node&lt;T&gt; next; <span class="hljs-comment">// 指向下一个节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; top;  <span class="hljs-comment">// 栈顶节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;     <span class="hljs-comment">// 栈的大小</span><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedStack</span><span class="hljs-params">()</span> &#123;<br>        top = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 初始时栈为空</span><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> top == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 压栈操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T element)</span> &#123;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(element);<br>        newNode.next = top; <span class="hljs-comment">// 新节点指向原栈顶</span><br>        top = newNode;      <span class="hljs-comment">// 栈顶指针指向新节点</span><br>        size++;             <span class="hljs-comment">// 栈大小加 1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 弹栈操作</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> top.data; <span class="hljs-comment">// 获取栈顶元素</span><br>        top = top.next;       <span class="hljs-comment">// 更新栈顶指针</span><br>        size--;               <span class="hljs-comment">// 栈大小减 1</span><br>        <span class="hljs-keyword">return</span> element;       <span class="hljs-comment">// 返回弹出的元素</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取栈顶元素但不弹出</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> top.data; <span class="hljs-comment">// 返回栈顶元素</span><br>    &#125;<br><br>    <span class="hljs-comment">// 栈的大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParenthesisMatcher</span> &#123;<br><br>    <span class="hljs-comment">// 检查括号是否匹配</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        LinkedStack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedStack</span>&lt;&gt;();<br>    <br>        <span class="hljs-comment">// 使用 HashMap 来映射括号的配对</span><br>        Map&lt;Character, Character&gt; pairMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        pairMap.put(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>        pairMap.put(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        pairMap.put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (pairMap.containsKey(c)) &#123;  <span class="hljs-comment">// 遇到右括号</span><br>                <span class="hljs-comment">// 弹栈并检查是否匹配</span><br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != pairMap.get(c)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 不匹配</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pairMap.containsValue(c)) &#123;  <span class="hljs-comment">// 遇到左括号</span><br>                stack.push(c);<br>            &#125;<br>        &#125;<br>    <br>        <span class="hljs-comment">// 如果栈为空，则所有括号都匹配</span><br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(&#123;[]&#125;)&quot;</span>;  <span class="hljs-comment">// 有效</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">test2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(&#123;[&#125;)&quot;</span>;   <span class="hljs-comment">// 无效</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">test3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;((()))&quot;</span>;  <span class="hljs-comment">// 有效</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">test4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;([)]&quot;</span>;    <span class="hljs-comment">// 无效</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-comment">// 有效（空字符串）</span><br><br>        System.out.println(<span class="hljs-string">&quot;Test 1: &quot;</span> + test1 + <span class="hljs-string">&quot; -&gt; &quot;</span> + isValid(test1));<br>        System.out.println(<span class="hljs-string">&quot;Test 2: &quot;</span> + test2 + <span class="hljs-string">&quot; -&gt; &quot;</span> + isValid(test2));<br>        System.out.println(<span class="hljs-string">&quot;Test 3: &quot;</span> + test3 + <span class="hljs-string">&quot; -&gt; &quot;</span> + isValid(test3));<br>        System.out.println(<span class="hljs-string">&quot;Test 4: &quot;</span> + test4 + <span class="hljs-string">&quot; -&gt; &quot;</span> + isValid(test4));<br>        System.out.println(<span class="hljs-string">&quot;Test 5: &quot;</span> + test5 + <span class="hljs-string">&quot; -&gt; &quot;</span> + isValid(test5));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="b-表达式求值"><a href="#b-表达式求值" class="headerlink" title="b. 表达式求值"></a>b. 表达式求值</h4><blockquote><p>表达式求值是计算一个算术表达式的值的过程。在计算机科学中，求值表达式的问题通常涉及到操作符的优先级、括号的处理以及操作符的结合性。常见的实现方式包括使用栈来处理表达式中的操作符和操作数。</p><h3 id="表达式求值的基本思路"><a href="#表达式求值的基本思路" class="headerlink" title="表达式求值的基本思路"></a>表达式求值的基本思路</h3><p>考虑到四则运算符 (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) 和括号的优先级问题，我们可以采用 <strong>中缀表达式转后缀表达式</strong>（又称为 <strong>逆波兰表示法</strong>）的技巧来简化问题。然后使用栈来处理后缀表达式的求值。</p><h3 id="1-中缀表达式转后缀表达式"><a href="#1-中缀表达式转后缀表达式" class="headerlink" title="1. 中缀表达式转后缀表达式"></a>1. 中缀表达式转后缀表达式</h3><p><strong>中缀表达式</strong>是我们常用的表达式形式，例如 <code>3 + 5 * (2 - 8)</code>。但是直接对中缀表达式进行求值比较复杂，因为需要考虑括号、运算符优先级等问题。</p><p><strong>后缀表达式</strong>（逆波兰表示法）是运算符跟随其操作数之后的一种表达式形式，例如 <code>3 5 2 8 - * +</code>。后缀表达式没有括号，因此不需要考虑运算符的优先级，可以直接从左到右按顺序计算。</p><p>我们可以通过一个栈将中缀表达式转换为后缀表达式。转换规则：</p><ul><li>如果是操作数，直接加入后缀表达式。</li><li>如果是左括号 <code>(</code>，压栈。</li><li>如果是右括号 <code>)</code>，弹出栈顶的操作符直到遇到左括号。</li><li>如果是运算符，弹出栈中优先级高于当前运算符的运算符，直到栈顶的运算符优先级低于当前运算符，或者栈为空。然后将当前运算符压入栈。</li></ul><h3 id="2-后缀表达式的求值"><a href="#2-后缀表达式的求值" class="headerlink" title="2. 后缀表达式的求值"></a>2. 后缀表达式的求值</h3><p>在得到后缀表达式后，我们可以使用一个栈来计算它的值。对于后缀表达式：</p><ul><li>如果是数字，直接压入栈。</li><li>如果是运算符，弹出栈顶的两个操作数，进行运算，然后将结果压入栈。</li></ul><p>最终栈中剩下的元素即为表达式的值。</p></blockquote><p>中缀转后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpressionEvaluator</span> &#123;<br><br>    <span class="hljs-comment">// 判断字符是否是操作符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOperator</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span> || c == <span class="hljs-string">&#x27;/&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取操作符的优先级</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPrecedence</span><span class="hljs-params">(<span class="hljs-type">char</span> operator)</span> &#123;<br>        <span class="hljs-keyword">if</span> (operator == <span class="hljs-string">&#x27;+&#x27;</span> || operator == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operator == <span class="hljs-string">&#x27;*&#x27;</span> || operator == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 转换中缀表达式为后缀表达式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">infixToPostfix</span><span class="hljs-params">(String expression)</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">postfix</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; expression.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> expression.charAt(i);<br><br>            <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>                <span class="hljs-comment">// 如果是数字，直接加入后缀表达式</span><br>                postfix.append(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 如果是左括号，压栈</span><br>                stack.push(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 如果是右括号，弹出直到遇到左括号</span><br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    postfix.append(stack.pop());<br>                &#125;<br>                stack.pop(); <span class="hljs-comment">// 弹出 &#x27;(&#x27;</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOperator(c)) &#123;<br>                <span class="hljs-comment">// 如果是操作符，弹出优先级更高或相等的运算符</span><br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; getPrecedence(stack.peek()) &gt;= getPrecedence(c)) &#123;<br>                    postfix.append(stack.pop());<br>                &#125;<br>                stack.push(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 弹出栈中的剩余运算符</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            postfix.append(stack.pop());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> postfix.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 求解后缀表达式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evaluatePostfix</span><span class="hljs-params">(String postfix)</span> &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; postfix.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> postfix.charAt(i);<br><br>            <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>                <span class="hljs-comment">// 如果是数字，将其压栈</span><br>                stack.push(c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOperator(c)) &#123;<br>                <span class="hljs-comment">// 如果是操作符，弹出两个操作数进行运算</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">operand2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">operand1</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>                <span class="hljs-keyword">switch</span> (c) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        result = operand1 + operand2;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        result = operand1 - operand2;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        result = operand1 * operand2;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                        result = operand1 / operand2;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 将计算结果压栈</span><br>                stack.push(result);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stack.pop(); <span class="hljs-comment">// 返回最后一个栈中的元素，即为表达式的值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3+(5-2)*4&quot;</span>; <span class="hljs-comment">// 示例表达式</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">postfix</span> <span class="hljs-operator">=</span> infixToPostfix(expression);<br>        System.out.println(<span class="hljs-string">&quot;Postfix Expression: &quot;</span> + postfix);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> evaluatePostfix(postfix);<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);  <span class="hljs-comment">// 输出结果</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><h3 id="1-队列的顺序存储-循环队列"><a href="#1-队列的顺序存储-循环队列" class="headerlink" title="1. 队列的顺序存储(循环队列)"></a>1. 队列的顺序存储(循环队列)</h3><blockquote><p>循环队列（Circular Queue）是一种特殊的队列实现，它利用数组来存储元素，且采用“环形”结构来有效地利用数组空间。在传统的队列中，当队列满时不能再插入新的元素，但在循环队列中，如果队列有空位（即队列前面的元素已经被删除），则可以重新利用这些空位。</p><h3 id="1-循环队列的特点："><a href="#1-循环队列的特点：" class="headerlink" title="1. 循环队列的特点："></a>1. 循环队列的特点：</h3><ul><li><p>使用一个固定大小的数组来存储队列的元素。</p></li><li><p>使用两个指针（</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">front</span><br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rear</span><br></code></pre></td></tr></table></figure><p>）来跟踪队列的头部和尾部：</p><ul><li>**<code>front</code>**：指向队列的第一个元素（出队）。</li><li>**<code>rear</code>**：指向队列的下一个空位置（入队）。</li></ul></li><li><p>当队列满时，<code>rear</code> 指针会追赶 <code>front</code> 指针，即出现队列空间的循环利用。</p></li><li><p>队列空时，<code>front</code> 和 <code>rear</code> 指针相等，队列满时，<code>rear</code> 的位置紧跟着 <code>front</code>，即 <code>(rear + 1) % capacity == front</code>。</p></li></ul><h3 id="2-循环队列的操作"><a href="#2-循环队列的操作" class="headerlink" title="2. 循环队列的操作"></a>2. 循环队列的操作</h3><ul><li>**入队 (enqueue)**：将元素加入队列的尾部。</li><li>**出队 (dequeue)**：从队列的头部移除元素。</li><li>**获取队头元素 (peek&#x2F;front)**：查看队头的元素但不移除它。</li><li>**判断队列是否为空 (isEmpty)**：如果 <code>front == rear</code>，则队列为空。</li><li>**判断队列是否为满 (isFull)**：如果 <code>(rear + 1) % capacity == front</code>，则队列为满。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] queue;      <span class="hljs-comment">// 存储队列元素的数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front;        <span class="hljs-comment">// 队列头部，指向第一个元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear;         <span class="hljs-comment">// 队列尾部，指向下一个可插入元素的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;         <span class="hljs-comment">// 当前队列中元素的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;     <span class="hljs-comment">// 队列的容量</span><br><br>    <span class="hljs-comment">// 构造函数，初始化队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CircularQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity + <span class="hljs-number">1</span>; <span class="hljs-comment">// 多留一个位置，用来区分空队列和满队列</span><br>        <span class="hljs-built_in">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.capacity];<br>        <span class="hljs-built_in">this</span>.front = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.rear = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断队列是否为满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 入队操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列已满，无法入队&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        queue[rear] = value;<br>        rear = (rear + <span class="hljs-number">1</span>) % capacity; <span class="hljs-comment">// 循环队列，更新 rear</span><br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 出队操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法出队&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 返回一个特殊值表示队列为空</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> queue[front];<br>        front = (front + <span class="hljs-number">1</span>) % capacity; <span class="hljs-comment">// 循环队列，更新 front</span><br>        size--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取队头元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue[front];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取队列中的元素个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印队列的内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> front;<br>        <span class="hljs-keyword">while</span> (current != rear) &#123;<br>            System.out.print(queue[current] + <span class="hljs-string">&quot; &quot;</span>);<br>            current = (current + <span class="hljs-number">1</span>) % capacity;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-comment">// 打印队列的详细信息（前端到后端）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printQueueDetails</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;队列内容: &quot;</span>);<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> front;<br>        <span class="hljs-keyword">while</span> (current != rear) &#123;<br>            System.out.print(queue[current] + <span class="hljs-string">&quot; &quot;</span>);<br>            current = (current + <span class="hljs-number">1</span>) % capacity;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="2-队列的链式存储结构"><a href="#2-队列的链式存储结构" class="headerlink" title="2. 队列的链式存储结构"></a>2. 队列的链式存储结构</h3><blockquote><p>在队列的链式存储结构中，我们使用链表来存储队列的元素。与顺序存储的队列（使用数组）不同，链式队列通过动态分配内存来存储元素，因此不受数组大小的限制，能够灵活地进行扩展。</p><h3 id="链式队列的特点："><a href="#链式队列的特点：" class="headerlink" title="链式队列的特点："></a>链式队列的特点：</h3><ul><li><strong>节点</strong>：每个队列元素包含数据部分和指向下一个元素的指针（即链表的结构）。</li><li><strong>头指针（front）</strong>：指向队列的第一个元素。</li><li><strong>尾指针（rear）</strong>：指向队列的最后一个元素。</li><li><strong>队列为空</strong>：当 <code>front == null</code> 时，队列为空。</li><li><strong>队列满</strong>：链式队列没有容量限制，不存在“满”的情况，只有在内存不足时才会出问题。</li></ul><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><ul><li>**入队 (enqueue)**：将元素插入队列的尾部，<code>rear</code> 指针向后移动。</li><li>**出队 (dequeue)**：从队列的头部移除元素，<code>front</code> 指针向后移动。</li><li>**获取队头元素 (peek&#x2F;front)**：查看队头元素但不移除它。</li><li>**判断队列是否为空 (isEmpty)**：通过 <code>front</code> 判断队列是否为空。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队列节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    Node next;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 链式队列实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Node front;  <span class="hljs-comment">// 队头指针</span><br>    <span class="hljs-keyword">private</span> Node rear;   <span class="hljs-comment">// 队尾指针</span><br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedQueue</span><span class="hljs-params">()</span> &#123;<br>        front = rear = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> front == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 入队操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-comment">// 如果队列为空，队头和队尾指针都指向新节点</span><br>            front = rear = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则，将新节点加入到队尾</span><br>            rear.next = newNode;<br>            rear = newNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 出队操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法出队&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 返回-1表示队列为空</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> front.data;<br>        front = front.next; <span class="hljs-comment">// 移动队头指针</span><br>        <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">null</span>) &#123;<br>            rear = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 如果队列为空，队尾指针也设为null</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取队头元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> front.data;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印队列的内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> front;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            current = current.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="3-双端队列"><a href="#3-双端队列" class="headerlink" title="3. 双端队列"></a>3. 双端队列</h3><h4 id="a-数组实现"><a href="#a-数组实现" class="headerlink" title="a. 数组实现"></a>a. 数组实现</h4><blockquote><h3 id="数组实现的双端队列的思路"><a href="#数组实现的双端队列的思路" class="headerlink" title="数组实现的双端队列的思路"></a>数组实现的双端队列的思路</h3><ul><li><strong>数组存储</strong>：我们用一个数组来存储双端队列的元素。</li><li><strong>头尾指针</strong>：我们使用 <code>front</code> 和 <code>rear</code> 两个指针分别表示队头和队尾的位置。</li><li><strong>循环数组</strong>：为了避免数组中元素插入后“移动”的问题，我们可以使用一个固定大小的数组，并通过将指针循环使用来模拟双端队列的行为。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDeque</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] deque;    <span class="hljs-comment">// 存储元素的数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front;      <span class="hljs-comment">// 队头指针</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rear;       <span class="hljs-comment">// 队尾指针</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;       <span class="hljs-comment">// 当前队列中的元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;   <span class="hljs-comment">// 队列的容量</span><br><br>    <span class="hljs-comment">// 构造函数，初始化队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity + <span class="hljs-number">1</span>; <span class="hljs-comment">// 为了区分空队列和满队列，多留一个位置</span><br>        <span class="hljs-built_in">this</span>.deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.capacity];<br>        <span class="hljs-built_in">this</span>.front = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.rear = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断队列是否为满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 从队头插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列已满，无法插入&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        front = (front - <span class="hljs-number">1</span> + capacity) % capacity;<br>        deque[front] = value;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 从队尾插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列已满，无法插入&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        deque[rear] = value;<br>        rear = (rear + <span class="hljs-number">1</span>) % capacity;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 从队头删除元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法删除&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 返回-1表示队列为空</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> deque[front];<br>        front = (front + <span class="hljs-number">1</span>) % capacity;<br>        size--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 从队尾删除元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法删除&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        rear = (rear - <span class="hljs-number">1</span> + capacity) % capacity;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> deque[rear];<br>        size--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取队头元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque[front];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取队尾元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque[(rear - <span class="hljs-number">1</span> + capacity) % capacity];<br>    &#125;<br><br>    <span class="hljs-comment">// 打印队列内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDeque</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> front;<br>        <span class="hljs-keyword">while</span> (current != rear) &#123;<br>            System.out.print(deque[current] + <span class="hljs-string">&quot; &quot;</span>);<br>            current = (current + <span class="hljs-number">1</span>) % capacity;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="b-使用链表实现"><a href="#b-使用链表实现" class="headerlink" title="b. 使用链表实现"></a>b. 使用链表实现</h4><blockquote><h3 id="链表实现的双端队列的思路"><a href="#链表实现的双端队列的思路" class="headerlink" title="链表实现的双端队列的思路"></a>链表实现的双端队列的思路</h3><ul><li><strong>双向链表</strong>：我们使用一个双向链表来存储元素，每个节点包含三个部分：元素值、指向前一个节点的指针、指向下一个节点的指针。</li><li><strong>队头和队尾指针</strong>：我们用两个指针 <code>front</code> 和 <code>rear</code> 分别指向链表的头部和尾部。</li></ul><h3 id="主要操作："><a href="#主要操作：" class="headerlink" title="主要操作："></a>主要操作：</h3><ul><li><strong>从队头插入元素</strong>（<code>addFirst()</code>）。</li><li><strong>从队尾插入元素</strong>（<code>addLast()</code>）。</li><li><strong>从队头删除元素</strong>（<code>removeFirst()</code>）。</li><li><strong>从队尾删除元素</strong>（<code>removeLast()</code>）。</li><li><strong>获取队头元素</strong>（<code>getFirst()</code>）。</li><li><strong>获取队尾元素</strong>（<code>getLast()</code>）。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 双向链表节点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    Node prev;<br>    Node next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.prev = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 双端队列实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedDeque</span> &#123;<br>    <span class="hljs-keyword">private</span> Node front;  <span class="hljs-comment">// 队头指针</span><br>    <span class="hljs-keyword">private</span> Node rear;   <span class="hljs-comment">// 队尾指针</span><br><br>    <span class="hljs-comment">// 构造函数，初始化双端队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedDeque</span><span class="hljs-params">()</span> &#123;<br>        front = rear = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> front == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 从队头插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            front = rear = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newNode.next = front;<br>            front.prev = newNode;<br>            front = newNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从队尾插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            front = rear = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newNode.prev = rear;<br>            rear.next = newNode;<br>            rear = newNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从队头删除元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法删除&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> front.data;<br>        front = front.next;<br>        <span class="hljs-keyword">if</span> (front != <span class="hljs-literal">null</span>) &#123;<br>            front.prev = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rear = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 如果队列为空</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 从队尾删除元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空，无法删除&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rear.data;<br>        rear = rear.prev;<br>        <span class="hljs-keyword">if</span> (rear != <span class="hljs-literal">null</span>) &#123;<br>            rear.next = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            front = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 如果队列为空</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取队头元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> front.data;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取队尾元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rear.data;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印队列内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDeque</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> front;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            current = current.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0. 线性表</title>
    <link href="/hexo-blog/2024/11/08/0.%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/hexo-blog/2024/11/08/0.%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="一、线性表的顺序表示"><a href="#一、线性表的顺序表示" class="headerlink" title="一、线性表的顺序表示"></a>一、线性表的顺序表示</h2><h3 id="线性表的顺序表示（顺序表）的定义"><a href="#线性表的顺序表示（顺序表）的定义" class="headerlink" title="线性表的顺序表示（顺序表）的定义"></a>线性表的顺序表示（顺序表）的定义</h3><p>线性表是一种数据元素按线性顺序排列的数据结构。在 Java 中，线性表的顺序表示通常是通过数组实现的。顺序表示的线性表是一种静态数据结构，其中的元素在内存中是连续存储的，可以通过索引快速访问。</p><p>在顺序表中，数据元素在逻辑上是连续的，而在物理存储上，它们通常是保存在一段连续的内存空间中。顺序表支持的基本操作包括：</p><ul><li><strong>插入</strong>：在表中某个位置插入元素。</li><li><strong>删除</strong>：删除表中某个位置的元素。</li><li><strong>查找</strong>：查找表中某个位置的元素。</li><li><strong>更新</strong>：更新表中某个位置的元素。</li></ul><h4 id="1-顺序表类定义"><a href="#1-顺序表类定义" class="headerlink" title="1.顺序表类定义"></a>1.顺序表类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeqList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Object[] data;  <span class="hljs-comment">// 用数组来存储线性表的数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;       <span class="hljs-comment">// 当前顺序表的大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;   <span class="hljs-comment">// 顺序表的容量</span><br><br>    <span class="hljs-comment">// 构造方法，初始化顺序表的容量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SeqList</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断顺序表是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断顺序表是否已满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取顺序表的大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">// 插入元素到顺序表的指定位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T element)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size == capacity) &#123;<br>            System.out.println(<span class="hljs-string">&quot;List is full&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 从后向前移动元素，给新元素腾出位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size; i &gt; index; i--) &#123;<br>            data[i] = data[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 插入新元素</span><br>        data[index] = element;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 从前向后移动元素，填补删除的元素位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; size - <span class="hljs-number">1</span>; i++) &#123;<br>            data[i] = data[i + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        size--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找指定位置的元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 更新指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T element)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        data[index] = element;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印顺序表中的所有元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            System.out.print(data[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-使用顺序表"><a href="#2-使用顺序表" class="headerlink" title="2. 使用顺序表"></a>2. 使用顺序表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个顺序表，容量为 5</span><br>        SeqList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeqList</span>&lt;&gt;(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 插入元素</span><br>        list.insert(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 在位置 0 插入 10</span><br>        list.insert(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 在位置 1 插入 20</span><br>        list.insert(<span class="hljs-number">1</span>, <span class="hljs-number">30</span>);  <span class="hljs-comment">// 在位置 1 插入 30</span><br>        list.insert(<span class="hljs-number">3</span>, <span class="hljs-number">40</span>);  <span class="hljs-comment">// 在位置 3 插入 40</span><br>        list.insert(<span class="hljs-number">4</span>, <span class="hljs-number">50</span>);  <span class="hljs-comment">// 在位置 4 插入 50</span><br><br>        System.out.println(<span class="hljs-string">&quot;顺序表内容：&quot;</span>);<br>        list.print();  <span class="hljs-comment">// 输出顺序表</span><br><br>        <span class="hljs-comment">// 获取指定位置的元素</span><br>        System.out.println(<span class="hljs-string">&quot;获取位置 2 的元素：&quot;</span> + list.get(<span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 更新元素</span><br>        list.update(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// 更新位置 2 的元素为 100</span><br>        System.out.println(<span class="hljs-string">&quot;更新位置 2 后的顺序表内容：&quot;</span>);<br>        list.print();<br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.delete(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 删除位置 1 的元素</span><br>        System.out.println(<span class="hljs-string">&quot;删除位置 1 后的顺序表内容：&quot;</span>);<br>        list.print();<br><br>        <span class="hljs-comment">// 尝试在无效位置插入</span><br>        list.insert(<span class="hljs-number">10</span>, <span class="hljs-number">60</span>);  <span class="hljs-comment">// 插入位置越界</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-实现动态扩容"><a href="#3-实现动态扩容" class="headerlink" title="3. 实现动态扩容"></a>3. 实现动态扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeqList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Object[] data;  <span class="hljs-comment">// 用数组来存储线性表的数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;       <span class="hljs-comment">// 当前顺序表的大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;   <span class="hljs-comment">// 顺序表的容量</span><br><br>    <span class="hljs-comment">// 构造方法，初始化顺序表的容量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SeqList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = initialCapacity;<br>        <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断顺序表是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断顺序表是否已满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == capacity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取顺序表的大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">// 动态扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 扩容为原来的 2 倍</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> capacity * <span class="hljs-number">2</span>;<br>        Object[] newData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newCapacity];<br>        System.arraycopy(data, <span class="hljs-number">0</span>, newData, <span class="hljs-number">0</span>, size); <span class="hljs-comment">// 将旧数据复制到新数组</span><br>        data = newData; <span class="hljs-comment">// 重新指向新的数组</span><br>        capacity = newCapacity; <span class="hljs-comment">// 更新容量</span><br>        System.out.println(<span class="hljs-string">&quot;Array resized to &quot;</span> + newCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">// 插入元素到顺序表的指定位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T element)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果顺序表已满，进行扩容</span><br>        <span class="hljs-keyword">if</span> (size == capacity) &#123;<br>            resize();<br>        &#125;<br><br>        <span class="hljs-comment">// 从后向前移动元素，给新元素腾出位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size; i &gt; index; i--) &#123;<br>            data[i] = data[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 插入新元素</span><br>        data[index] = element;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 从前向后移动元素，填补删除的元素位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; size - <span class="hljs-number">1</span>; i++) &#123;<br>            data[i] = data[i + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        size--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找指定位置的元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 更新指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T element)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        data[index] = element;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印顺序表中的所有元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            System.out.print(data[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二、线性表的链式表示"><a href="#二、线性表的链式表示" class="headerlink" title="二、线性表的链式表示"></a>二、线性表的链式表示</h2><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h3><h4 id="a-定义链表结点Node"><a href="#a-定义链表结点Node" class="headerlink" title="a. 定义链表结点Node"></a>a. 定义链表结点Node</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    T data;       <span class="hljs-comment">// 存储数据</span><br>    Node&lt;T&gt; next; <span class="hljs-comment">// 指向下一个节点的引用</span><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="b-定义链表类"><a href="#b-定义链表类" class="headerlink" title="b. 定义链表类"></a>b. 定义链表类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; head;  <span class="hljs-comment">// 链表的头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;      <span class="hljs-comment">// 链表的大小</span><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>        head = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 初始化时链表为空</span><br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 获取链表的大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 判断链表是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 在链表头插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtHead</span><span class="hljs-params">(T data)</span> &#123;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>        newNode.next = head;<br>        head = newNode;<br>        size++;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 在链表尾插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtTail</span><span class="hljs-params">(T data)</span> &#123;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;T&gt; current = head;<br>            <span class="hljs-keyword">while</span> (current.next != <span class="hljs-literal">null</span>) &#123;<br>                current = current.next;<br>            &#125;<br>            current.next = newNode;<br>        &#125;<br>        size++;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 在指定位置插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            insertAtHead(data);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index - <span class="hljs-number">1</span>; i++) &#123;<br>            current = current.next;<br>        &#125;<br>        newNode.next = current.next;<br>        current.next = newNode;<br>        size++;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 删除指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            head = head.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;T&gt; current = head;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index - <span class="hljs-number">1</span>; i++) &#123;<br>                current = current.next;<br>            &#125;<br>            current.next = current.next.next;<br>        &#125;<br>        size--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 查找指定位置的元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> current.data;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 更新指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            current = current.next;<br>        &#125;<br>        current.data = data;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 打印链表的所有元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            current = current.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2. 双链表"></a>2. 双链表</h3><h4 id="a-定义双链表节点类-Node"><a href="#a-定义双链表节点类-Node" class="headerlink" title="a. 定义双链表节点类 Node"></a>a. 定义双链表节点类 <code>Node</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    T data;       <span class="hljs-comment">// 存储数据</span><br>    Node&lt;T&gt; next; <span class="hljs-comment">// 指向下一个节点</span><br>    Node&lt;T&gt; prev; <span class="hljs-comment">// 指向前一个节点</span><br>  <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="b-定义双链表类"><a href="#b-定义双链表类" class="headerlink" title="b. 定义双链表类"></a>b. 定义双链表类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; head;  <span class="hljs-comment">// 链表头节点</span><br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; tail;  <span class="hljs-comment">// 链表尾节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;      <span class="hljs-comment">// 链表的大小</span><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoublyLinkedList</span><span class="hljs-params">()</span> &#123;<br>        head = <span class="hljs-literal">null</span>;<br>        tail = <span class="hljs-literal">null</span>;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 获取链表大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 判断链表是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 在链表头插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtHead</span><span class="hljs-params">(T data)</span> &#123;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = newNode;<br>            tail = newNode; <span class="hljs-comment">// 如果链表为空，头尾指针指向同一个节点</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newNode.next = head;<br>            head.prev = newNode;<br>            head = newNode;<br>        &#125;<br>        size++;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 在链表尾插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtTail</span><span class="hljs-params">(T data)</span> &#123;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>        <span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">null</span>) &#123;<br>            head = newNode;<br>            tail = newNode; <span class="hljs-comment">// 如果链表为空，头尾指针指向同一个节点</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.next = newNode;<br>            newNode.prev = tail;<br>            tail = newNode;<br>        &#125;<br>        size++;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 在指定位置插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            insertAtHead(data);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == size) &#123;<br>            insertAtTail(data);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>            Node&lt;T&gt; current = head;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>                current = current.next;<br>            &#125;<br>            newNode.next = current;<br>            newNode.prev = current.prev;<br>            current.prev.next = newNode;<br>            current.prev = newNode;<br>            size++;<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 删除指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (head == tail) &#123;<br>                head = tail = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 如果链表中只有一个元素</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head = head.next;<br>                head.prev = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == size - <span class="hljs-number">1</span>) &#123;<br>            tail = tail.prev;<br>            tail.next = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;T&gt; current = head;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>                current = current.next;<br>            &#125;<br>            current.prev.next = current.next;<br>            current.next.prev = current.prev;<br>        &#125;<br>        size--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 查找指定位置的元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> current.data;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 更新指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            current = current.next;<br>        &#125;<br>        current.data = data;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 打印链表的所有元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            current = current.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>  <br>    <span class="hljs-comment">// 打印链表从尾到头的元素（反向遍历）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printReverse</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;T&gt; current = tail;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            current = current.prev;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-循环链表"><a href="#3-循环链表" class="headerlink" title="3. 循环链表"></a>3. 循环链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    T data;       <span class="hljs-comment">// 存储数据</span><br>    Node&lt;T&gt; next; <span class="hljs-comment">// 指向下一个节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(T data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularLinkedList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; head;  <span class="hljs-comment">// 链表头节点</span><br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; tail;  <span class="hljs-comment">// 链表尾节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;      <span class="hljs-comment">// 链表的大小</span><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CircularLinkedList</span><span class="hljs-params">()</span> &#123;<br>        head = <span class="hljs-literal">null</span>;<br>        tail = <span class="hljs-literal">null</span>;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取链表大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断链表是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在链表头插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtHead</span><span class="hljs-params">(T data)</span> &#123;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = newNode;<br>            tail = newNode; <span class="hljs-comment">// 如果链表为空，头尾指针都指向新节点</span><br>            newNode.next = head; <span class="hljs-comment">// 循环链表的尾节点指向头节点</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newNode.next = head;<br>            head = newNode;<br>            tail.next = head; <span class="hljs-comment">// 确保尾节点指向头节点</span><br>        &#125;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 在链表尾插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtTail</span><span class="hljs-params">(T data)</span> &#123;<br>        Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = newNode;<br>            tail = newNode; <span class="hljs-comment">// 如果链表为空，头尾指针都指向新节点</span><br>            newNode.next = head; <span class="hljs-comment">// 循环链表的尾节点指向头节点</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.next = newNode;<br>            tail = newNode;<br>            tail.next = head; <span class="hljs-comment">// 尾节点指向头节点</span><br>        &#125;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 在指定位置插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            insertAtHead(data);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == size) &#123;<br>            insertAtTail(data);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(data);<br>            Node&lt;T&gt; current = head;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index - <span class="hljs-number">1</span>; i++) &#123;<br>                current = current.next;<br>            &#125;<br>            newNode.next = current.next;<br>            current.next = newNode;<br>            size++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (head == tail) &#123;<br>                head = <span class="hljs-literal">null</span>;<br>                tail = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 如果链表中只有一个元素</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head = head.next;<br>                tail.next = head; <span class="hljs-comment">// 确保尾节点指向新的头节点</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;T&gt; current = head;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index - <span class="hljs-number">1</span>; i++) &#123;<br>                current = current.next;<br>            &#125;<br>            current.next = current.next.next;<br>            <span class="hljs-keyword">if</span> (index == size - <span class="hljs-number">1</span>) &#123;<br>                tail = current; <span class="hljs-comment">// 如果删除的是尾节点，更新尾节点</span><br>            &#125;<br>        &#125;<br>        size--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找指定位置的元素</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            current = current.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> current.data;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新指定位置的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            current = current.next;<br>        &#125;<br>        current.data = data;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印链表的所有元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;The list is empty.&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node&lt;T&gt; current = head;<br>        <span class="hljs-keyword">do</span> &#123;<br>            System.out.print(current.data + <span class="hljs-string">&quot; &quot;</span>);<br>            current = current.next;<br>        &#125; <span class="hljs-keyword">while</span> (current != head); <span class="hljs-comment">// 循环直到回到头节点</span><br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
